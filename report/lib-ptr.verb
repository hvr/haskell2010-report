\section{@Foreign.Ptr@}
\label{sec:Ptr}

The module @Foreign.Ptr@ provides typed pointers to foreign entities.  We
distinguish two kinds of pointers: pointers to data and pointers to functions.
It is understood that these two kinds of pointers may be represented
differently as they may be references to data and text segments, respectively.

\paragraph{Data Pointers}

The interface defining data pointers and associated operations is as follows:
%
\begin{codedesc}
\item[data Ptr a] A value of type @Ptr a@ represents a pointer to an
  object, or an array of objects, which may be marshalled to or from Haskell
  values of type @a@.  The type @a@ will normally be an instance of
  class @Storable@ (see Section~\ref{sec:Storable}), which provides the
  necessary marshalling operations.

  Instances for the classes @Eq@, @Ord@, and @Show@ are
  provided. 
\item[nullPtr ::\ Ptr a] The constant @nullPtr@ contains a distinguished
  value of @Ptr@ that is not associated with a valid memory location.
\item[castPtr ::\ Ptr a -> Ptr b] The @castPtr@ function casts a pointer
  from one type to another.
\item[plusPtr ::\ Ptr a -> Int -> Ptr b] Advances the given address by the
  given offset in bytes.
\item[alignPtr ::\ Ptr a -> Int -> Ptr a] Given an arbitrary address and an
  alignment constraint, @alignPtr@ yields an address, the same or next
  higher, that fulfills the alignment constraint. An alignment constraint
  @x@ is fulfilled by any address divisible by @x@. This operation
  is idempotent.
\item[minusPtr ::\ Ptr a -> Ptr b -> Int] Compute the offset required to get
  from the first to the second argument.  We have
  %
  \begin{quote}
\begin{verbatim}
p2 == p1 `plusPtr` (p2 `minusPtr` p1)
\end{verbatim}
  \end{quote}
\end{codedesc}
%
It should be noted that the use of @Int@ for pointer differences
essentially forces any implementation to represent @Int@ in as many bits
as used in the representation of pointer values.

\paragraph{Function Pointers}

The interface defining function pointers and associated operations is as
follows:
%
\begin{codedesc}
\item[data FunPtr a] A value of type @FunPtr a@ is a pointer to a piece
  of code.  It may be the pointer to a C function or to a Haskell function
  created using a wrapper stub as outlined in Section~\ref{sec:ccall}. For
  example,
  %
  \begin{quote}
\begin{verbatim}
type Compare = Int -> Int -> Bool
foreign import ccall "wrapper" 
  mkCompare :: Compare -> IO (FunPtr Compare)
\end{verbatim}
  \end{quote}
  
  Instances for the classes @Eq@, @Ord@, and @Show@ are
  provided.
\item[nullFunPtr ::\ FunPtr a] The constant @nullFunPtr@ contains a
  distinguished value of @FunPtr@ that is not associated with a valid
  memory location.
\item[castFunPtr ::\ FunPtr a -> FunPtr b] Cast a @FunPtr@ to a
  @FunPtr@ of a different type.
\item[freeHaskellFunPtr ::\ FunPtr a -> IO ()] Release the storage associated
  with the given @FunPtr@, which must have been obtained from a wrapper
  stub.  This should be called whenever the return value from a foreign import
  wrapper function is no longer required; otherwise, the storage it uses will
  leak.
\end{codedesc}

Moreover, there are two functions that are only valid on architectures where
data and function pointers range over the same set of addresses.  Only where
bindings to external libraries are made whose interface already relies on this
assumption, should the use of @castFunPtrToPtr@ and
@castPtrToFunPtr@ be considered; otherwise, it is recommended to avoid
using these functions.
%
\begin{codedesc}
\item[castFunPtrToPtr ::\ FunPtr a -> Ptr b]
\item[castPtrToFunPtr ::\ Ptr a -> FunPtr b] \combineitems These two functions
  cast @Ptr@s to @FunPtr@s and vice versa.
\end{codedesc}
