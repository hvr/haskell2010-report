\section{@Foreign.C.String@}
\label{sec:CString}

The module @Foreign.C.String@ provides routines marshalling Haskell into C strings
and vice versa.  The marshalling converts each Haskell character, representing
a Unicode code point, to one or more bytes in a manner that, by default, is
determined by the current locale.  As a consequence, no guarantees can be made
about the relative length of a Haskell string and its corresponding C string,
and therefore, all routines provided by @Foreign.C.String@ combine memory
allocation and marshalling.  The translation between Unicode and the encoding
of the current locale may be lossy.  The function @charIsRepresentable@
identifies the characters that can be accurately translated; unrepresentable
characters are converted to `?'.
%
\begin{codedesc}
\item[type CString = Ptr CChar] A C string is a reference to an array of C
  characters terminated by NUL.
  
\item[type CStringLen = (Ptr CChar, Int)] In addition to NUL-terminated
  strings, the module @Foreign.C.String@ also supports strings with explicit
  length information in bytes.

\item[peekCString~~~~::\ CString~~~~-> IO String]
\item[peekCStringLen~::\ CStringLen~-> IO String]\combineitems
  Marshal a C string to Haskell.  There are two variants of the routine, one
  for each supported string representation.

\item[newCString~~~~::\ String -> IO CString]
\item[newCStringLen~::\ String -> IO CStringLen] \combineitems Allocate a
  memory area for a Haskell string and marshal the string into its C
  representation.  There are two variants of the routine, one for each
  supported string representation.  The memory area allocated by these
  routines may be deallocated using @Foreign.Marshal.Alloc.free@.

\item[withCString~~~~::\ String -> (CString~~~~-> IO a) -> IO a]
\item[withCStringLen~::\ String -> (CStringLen~-> IO a) -> IO a] \combineitems
  These two routines operate as @newCString@ and @newCStringLen@,
  respectively, but handle memory allocation and deallocation like
  @Foreign.Marshal.Alloc.alloca@ (Section~\ref{sec:MarshalAlloc}).
  
\item[charIsRepresentable ::\ Char -> IO Bool] Determine whether the argument
  can be represented in the current locale.

\end{codedesc}

Some C libraries require to ignore the Unicode capabilities of Haskell and
treat values of type @Char@ as single byte characters.  Hence, the module
@CString@ provides a variant of the above marshalling routines that
truncates character sets correspondingly.  These functions should be used with
care, as a loss of information can occur.
%
\begin{codedesc}
\item[castCharToCChar ::\ Char -> CChar]
\item[castCCharToChar ::\ CChar -> Char] \combineitems These two functions cast
  Haskell characters to C characters and vice versa while ignoring the Unicode
  encoding of the Haskell character.  More precisely, only the first 256
  character points are preserved.

\item[peekCAString~~~~::\ CString~~~~-> IO String]
\item[peekCAStringLen~::\ CStringLen~-> IO String]\combineitems
\item[newCAString~~~~~::\ String -> IO CString]\combineitems
\item[newCAStringLen~~::\ String -> IO CStringLen] \combineitems
\item[withCAString~~~~::\ String -> (CString~~~~-> IO a) -> IO a]\combineitems
\item[withCAStringLen~::\ String -> (CStringLen~-> IO a) -> IO a]
  \combineitems These functions for whole-string marshalling cast Haskell
  characters to C characters and vice versa while ignoring the Unicode
  encoding of Haskell characters.
\end{codedesc}

To simplify bindings to C libraries that use @wchar_t@ for character
sets that cannot be encoded in byte strings, the module @Foreign.C.String@ also
exports a variant of the above string marshalling routines for wide
characters---i.e., for the C @wchar_t@ type.\footnote{Note that if the
  platform defines @__STDC_ISO_10646__@ then @wchar_t@
  characters are Unicode code points, and thus, the conversion between Haskell
  @Char@ and @CWchar@ is a simple cast.  On other platforms, the
  translation is locale-dependent, just as for @CChar@.}
%
\begin{codedesc}
\item[type CWString~~~~= Ptr CWchar]
\item[type CWStringLen~= (Ptr CWchar, Int)] \combineitems
  Wide character strings in a NUL-terminated version and a variant with
  explicit length information in number of wide characters.

\item[peekCWString~~~~::\ CWString~~~~-> IO String]
\item[peekCWStringLen~::\ CWStringLen~-> IO String]\combineitems
\item[newCWString~~~~~::\ String -> IO CWString]\combineitems
\item[newCWStringLen~~::\ String -> IO CWStringLen] \combineitems
\item[withCWString~~~~::\ String -> (CWString~~~~-> IO a) -> IO a]\combineitems
\item[withCWStringLen~::\ String -> (CWStringLen~-> IO a) -> IO a]
  \combineitems String marshalling for wide character strings.  The interface
  is the same as for byte strings.
\end{codedesc}
