\section{@Foreign@}
\label{sec:Foreign}

The module @Foreign@ combines the interfaces of all modules providing
language-independent marshalling support, namely
\begin{itemize}
\item @Data.Bits@
\item @Data.Int@
\item @Data.Word@
\item @Foreign.Ptr@
\item @Foreign.ForeignPtr@
\item @Foreign.StablePtr@
\item @Foreign.Storable@
\item @Foreign.Marshal.Alloc@
\item @Foreign.Marshal.Array@
\item @Foreign.Marshal.Error@
\item @Foreign.Marshal.Utils@
\end{itemize}

% Removed from the FFI spec in favor of
% Foreign.Marshal.unsafeLocalState in Haskell 2010:

% Sometimes an external entity is a pure function, except that it passes
% arguments and/or results via pointers.  To permit the packaging of
% such entities as pure functions, @Foreign@ provides the following
% primitive:
% %
% \begin{codedesc}
% \item[unsafePerformIO ::\ IO a -> a] Return the value resulting from executing
%   the @IO@ action.  This value should be independent of the environment;
%   otherwise, the system behaviour is undefined.
%   
%   If the @IO@ computation wrapped in @unsafePerformIO@ performs side
%   effects, then the relative order in which those side effects take place
%   (relative to the main @IO@ trunk, or other calls to
%   @unsafePerformIO@) is indeterminate.  Moreover, the side effects may be
%   performed several times or not at all, depending on lazy evaluation and
%   whether the compiler unfolds an enclosing definition.
%   
%   Great care should be exercised in the use of this primitive.  Not only
%   because of the danger of introducing side effects, but also because
%   @unsafePerformIO@ may compromise typing; to avoid this, the programmer
%   should ensure that the result of @unsafePerformIO@ has a monomorphic
%   type.
% \end{codedesc}
