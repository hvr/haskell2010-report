\section{@Foreign.Marshal@}
\label{sec:ForeignMarshal}

\begin{outlineenv}
@
module Foreign.Marshal
        ( module Foreign.Marshal.Alloc
        , module Foreign.Marshal.Array
        , module Foreign.Marshal.Error
        , module Foreign.Marshal.Utils
        , unsafeLocalState
        ) where

import Foreign.Marshal.Alloc
import Foreign.Marshal.Array
import Foreign.Marshal.Error
import Foreign.Marshal.Utils

unsafeLocalState :: IO a -> a
@
\end{outlineenv}

% Sometimes an external entity is a pure function, except that it passes
% arguments and/or results via pointers.  To permit the packaging of
% such entities as pure functions, @Foreign@ provides the following
% primitive:
% %
% \begin{codedesc}
% \item[unsafePerformIO ::\ IO a -> a] Return the value resulting from executing
%   the @IO@ action.  This value should be independent of the environment;
%   otherwise, the system behaviour is undefined.
%   
%   If the @IO@ computation wrapped in @unsafePerformIO@ performs side
%   effects, then the relative order in which those side effects take place
%   (relative to the main @IO@ trunk, or other calls to
%   @unsafePerformIO@) is indeterminate.  Moreover, the side effects may be
%   performed several times or not at all, depending on lazy evaluation and
%   whether the compiler unfolds an enclosing definition.
%   
%   Great care should be exercised in the use of this primitive.  Not only
%   because of the danger of introducing side effects, but also because
%   @unsafePerformIO@ may compromise typing; to avoid this, the programmer
%   should ensure that the result of @unsafePerformIO@ has a monomorphic
%   type.
% \end{codedesc}

The module @Foreign.Marshal@ re-exports the other modules in the
@Foreign.Marshal@ hierarchy, and defines one function:


\begin{codedesc}
\item[unsafeLocalState ::\ IO a -> a]
Sometimes an external entity is a pure function, except that it passes
arguments and/or results via pointers.  The function
@unsafeLocalState@ permits the packaging of such entities as pure
functions.  

The only IO operations allowed in the IO action passed to
@unsafeLocalState@ are (a) local allocation (@alloca@, @allocaBytes@
and derived operations such as @withArray@ and @withCString@), and (b)
pointer operations (@Foreign.Storable@ and @Foreign.Ptr@) on the
pointers to local storage, and (c) foreign functions whose only
observable effect is to read and/or write the locally allocated
memory.  Passing an IO operation that does not obey these rules
results in undefined behaviour.

It is expected that this operation will be
replaced in a future revision of Haskell.
\end{codedesc}
