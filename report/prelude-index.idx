<title> Haskell 98 Prelude Index </title>
<body bgcolor="##ffffff"><i>The Haskell 98 Report</i><br>
<a href="index.html">top</a><hr>

<h3> Index of the Haskell 98 Prelude </h3>

<h4> Types and Synonyms </h4>
Instances which are not defined by Haskell code the Prelude (a ... is used)
are not hyperlinked.
<p>
<pre>
data #T() = ()  deriving (Eq, Ord, Enum, Bounded) #S6.1.5
      Instances: #IRead#() #IShow#()
data #T[a] = [] | a : [a]  deriving (Eq, Ord) #S6.1.3
      Instances: #IRead#[a] #IShow#[a] #IFunctor#[a] #IMonad#[a]
data #T(a,b) = (a,b) deriving (Eq, Ord, Bounded) #S6.1.4 
      Instances: #IRead#(a,b) #IShow#(a,b)
data a->b #S6.1.6
data #TBool = False | True deriving (Eq, Ord, Enum, Read, Show, Bounded) #S6.1.1
data #TChar #S6.1.2
       Instances: Eq Ord #IEnum#Char #IRead#Char #IShow#Char 
data #TDouble #S6.4 
       Instances: Eq Ord Enum Read Show Num Real Fractional RealFrac Floating RealFloat
data #TEither a b  e=  Left a | Right b deriving (Eq, Ord, Read, Show) #S6.1.8
type #TFilePath =  String #S7.1
data #TFloat #S6.4
       Instances: Eq Ord Enum Read Show Num Real Fractional RealFrac Floating RealFloat
data #TInt #S6.4
       Instances: Eq Ord Enum Read Show Num Real Integral Bounded
data #TInteger #S6.4
       Instances: Eq Ord Enum Read Show Num Real Integral
data #TIO a #S6.1.7
       Instances: #IFunctor#IO Monad
data #TIOError #S6.1.7
       Instances: Show Eq
data #TMaybe a  =  Nothing | Just a deriving (Eq, Ord, Read, Show) #S6.1.8
        Instances: #IFunctor#Maybe #IMonad#Maybe
data #TOrdering = LT | EQ | GT  deriving (Eq, Ord, Enum, Read, Show, Bounded) #S6.1.8
type #TReadS a = String -> [(a,String)] #S6.3.3
type #TShowS = String -> String #S6.3.3
type #TString = [Char] #S6.1.2
</pre>

<h4> Constructors </h4>
<pre>
#L[]#T[a]
#L:#T[a]
#L(,)#T(a,b)
#LEQ#TOrdering
#LFalse#TBool
#LGT#TOrdering
#LJust#TMaybe
#LLeft#TEither
#LLT#TOrdering
#LNothing#TMaybe
#LRight#TEither
#LTrue#TBool

</pre>

<h4> Classes </h4>
<pre>
class                             #TBounded a    #S6.3.7
class                             #TEnum a       #S6.3.4
class                             #TEq a         #S6.3.1
class           (Fractional a) => #TFloating a   #S6.4
class                  (Num a) => #TFractional a #S6.4
class                             #TFunctor f    #S6.3.5
class         (Real a, Enum a) => #TIntegral a   #S6.4
class                             #TMonad m      #S6.3.6
class           (Eq a, Show a) => #TNum a        #S6.4
class                   (Eq a) => #TOrd a        #S6.3.2
class                             #TRead a       #S6.3.3
class           (Num a, Ord a) => #TReal a       #S6.4
class (RealFrac a, Floating a) => #TRealFloat a  #S6.4  
class   (Real a, Fractional a) => #TRealFrac a   #S6.4
class                             #TShow a       #S6.3.3 

</pre>
<h4> Functions and Methods </h4>
<table>
#table
#V(!!)             :: [a] -> Int -> a #&[0,1,2] !! 1 = 1
#V($)              :: (a -> b) -> a -> b #&f x $ g y = f x (g y)    
#V($!)             :: (a -> b) -> (a -> b) #&#S6.2
#V(&&)             :: Bool -> Bool -> Bool #&Boolean `and'
#V(||)             :: Bool -> Bool -> Bool #&Boolean `or'
#V(*)              :: Num a => a -> a -> a 
#V(**)             :: Floating a => a -> a -> a 
#V(+)              :: Num a => a -> a -> a
#V(++)             :: [a] -> [a] -> [a] #&"abc" ++ "def" = "abcdef"
#V(-)              :: Num a => a -> a -> a 
#V(.)              :: (b -> c) -> (a -> b) -> a -> c #&Function composition
#V(/)              :: Fractional a => a -> a -> a 
#V(/=)             :: Eq a => a -> a -> Bool #&not equal
#V(<)              :: Ord a => a -> a -> Bool 
#V(<=)             :: Ord a => a -> a -> Bool 
#V(==)             :: Eq a => a -> a -> Bool 
#V(=<<)            :: Monad a => (a -> m b) -> m a -> m b  #&Monadic binding #S6.3.6
#V(>)              :: Ord a => a -> a -> Bool 
#V(>=)             :: Ord a => a -> a -> Bool 
#V(>>)             :: Monad m => m a -> m b -> m b #&Monadic binding #S6.3.6
#V(>>=)            :: Monad m => m a -> (a -> m b) -> m b #&Monadic binding #S6.3.6
#V(^)              :: (Num a, Integral b) => a -> b -> a 
#V(^^)             :: (Fractional a, Integral b) => a -> b -> a #&negative exponent allowed
#Vabs              :: Num a => a -> a 
#Vacos             :: Floating a => a -> a 
#Vacosh            :: Floating a => a -> a 
#Vall              :: (a -> Bool) -> [a] -> Bool #&all (/= 'a') "cba" = False
#Vand              :: [Bool] -> Bool #&and [True, True, True] = True
#Vany              :: (a -> Bool) -> [a] -> Bool #&any (== 'c') "abc" = True
#VappendFile       :: FilePath -> String -> IO ()
#VapplyM           :: Monad m => (a -> m b) -> m a -> m b
#VasTypeOf         :: a -> a -> a #&Sort of a type cast
#Vasin             :: Floating a => a -> a 
#Vasinh            :: Floating a => a -> a 
#Vatan             :: Floating a => a -> a 
#Vatan2            :: RealFrac a => a -> a 
#Vatanh            :: Floating a => a -> a 
#Vbreak            :: (a -> Bool) -> [a] -> ([a], [a]) #&break (<2) [1,2,3] = ([1],[2,3])
#Vcatch            :: IO a -> (IOError -> IO a) -> IO a 
#Vceiling          :: (RealFrac a, Integral b) => a -> b 
#Vcompare          :: Ord a => a -> a -> Ordering 
#Vconcat           :: MonadPlus m => [m a] -> m a #&concat ["a","bc","d"] = "abcd"
#VconcatMap        :: (a -> [b]) -> [a] -> [b]
#Vconst            :: a -> b -> a
#Vcos              :: Floating a => a -> a 
#Vcosh             :: Floating a => a -> a 
#Vcurry            :: ((a, b) -> c) -> a -> b -> c
#Vcycle            :: [a] -> [a] #&cycle "abc" = "abcabcabc ..."
#VdecodeFloat      :: RealFloat a => a -> (Integer, Int) 
#Vdiv              :: Integral a => a -> a -> a 
#VdivMod           :: Integral a => a -> a -> (a, a) 
#Vdrop             :: Int -> [a] -> [a] #&drop 2 "abcd" = "cd"
#VdropWhile        :: (a -> Bool) -> [a] -> [a] #&dropWhile (>3) [5,3,5] = [3,5]
#Velem             :: Eq a => a -> [a] -> Bool #&'a' `elem` "abc" = True
#VencodeFloat      :: RealFloat a => Integer -> Int -> a 
#VenumFrom         :: Enum a => a -> [a] #&[n..]
#VenumFromThen     :: Enum a => a -> a -> [a] #&[m,n..]
#VenumFromThenTo   :: Enum a => a -> a -> a -> [a] #&[m,n..o]
#VenumFromTo       :: Enum a => a -> a -> [a] #&[m..n]
#Verror            :: String -> a #& #S3.1
#Veven             :: Integral a => a -> Bool
#Vexp              :: Floating a => a -> a 
#Vexponent         :: RealFloat a => a -> Int 
#Vfail             :: Monad m => String -> m a
#Vflip             :: (a -> b -> c) -> (b -> a -> c)
#VfloatDigits      :: RealFloat a => a -> Int 
#VfloatRadix       :: RealFloat a => a -> Integer 
#VfloatRange       :: RealFloat a => a -> (Int, Int) 
#Vfloor            :: (RealFrac a, Integral b) => a -> b 
#Vfoldl            :: (a -> b -> a) -> a -> [b] -> a #&foldl (+) 0 [a,b,c] = ((a+b)+c)+0
#Vfoldl1           :: (a -> a -> a) -> [a] -> a #&foldl1 (+) [a,b,c] = (a+b)+c
#Vfoldr            :: (a -> b -> b) -> b -> [a] -> b #&foldr (+) 0 [a,b,c] = 0+(a+(b+c))
#Vfoldr1           :: (a -> a -> a) -> [a] -> a #&foldr (+) [a,b,c] = a+(b+c)
#VfromEnum         :: Enum a => a -> Int 
#VfromInteger      :: Num a => Integer -> a #&#S3.2
#VfromIntegral     :: (Integral a, Num b) => a -> b
#VfromRational     :: Fractional a => Rational -> a #&#S3.2
#Vfst              :: (a, b) -> a
#Vgcd              :: (Integral a) => a -> a -> a
#VgetChar          :: IO Char #&eof generates an IOError
#VgetContents      :: IO String
#VgetLine          :: IO Char #&eof generates an IOError
#Vhead             :: [a] -> a
#Vid               :: a -> a
#Vinit             :: [a] -> [a]#&init "abcd" = "abc"
#Vinteract         :: (String -> String) -> IO ()
#VioError          :: IOError -> IO a 
#VisDenormalized   :: RealFloat a => a -> Bool 
#VisIEEE           :: RealFloat a => a -> Bool 
#VisInfinite       :: RealFloat a => a -> Bool 
#VisNaN            :: RealFloat a => a -> Bool 
#VisNegativeZero   :: RealFloat a => a -> Bool 
#Viterate          :: (a -> a) -> a -> [a] #&iterate (++ " ") "" = ["", " ", "  ",...]
#Vlast             :: [a] -> a #&last "abcde" = "e"
#Vlcm              :: Integral a => a -> a -> a
#Vlength           :: [a] -> Int #&length "Abc" = 3
#Vlex              :: ReadS String #&lex "abc def" = [("abc"," def")]
#Vlines            :: String -> [String]
#Vlog              :: Floating a => a -> a 
#VlogBase          :: Floating a => a -> a -> a 
#Vlookup           :: Eq a => a -> [(a, b)] -> Maybe b
#Vmap              :: Functor f => (a -> b) -> f a -> f b 
#VmapM             :: Monad m => (a -> m b) -> [a] -> m [b]
#VmapM_            :: Monad m => (a -> m b) -> [a] -> m ()
#Vmax              :: Ord a => a -> a -> a 
#VmaxBound         :: Bounded a => a 
#Vmaximum          :: Ord a => [a] -> a
#Vmaybe            :: b -> (a -> b) -> Maybe a -> b #&maybe 0 (+1) (Just 1) = 2
#Vmin              :: Ord a => a -> a -> a 
#VminBound         :: Bounded a => a 
#Vminimum          :: Ord a => [a] -> a
#Vmod              :: Integral a => a -> a -> a 
#Vnegate           :: Num a => a -> a 
#Vnot              :: Bool -> Bool
#VnotElem          :: Eq a => a -> [a] -> Bool
#Vnull             :: [a] -> Bool
#Vodd              :: Integral a => a -> Bool
#Vor               :: [Bool] -> Bool
#Votherwise        :: Bool
#Vpi               :: Floating a => a 
#Vpred             :: Enum a => a -> a #&pred True = False
#Vprint            :: Show a => IO () #&adds a newline
#Vproduct          :: Num a => [a] -> a
#VproperFraction   :: (RealFrac a, Integral b) => a -> (b, a) 
#VputChar          :: Char -> IO ()
#VputStr           :: String -> IO ()
#VputStrLn         :: String -> IO () #&adds a newline
#Vquot             :: Integral a => a -> a -> a 
#VquotRem          :: Integral a => a -> a -> (a, a) 
#Vread             :: Read a => String -> a
#VreadFile         :: FilePath -> IO String
#VreadIO           :: Read a => String -> IO a #&fails with IOError
#VreadList         :: Read a => ReadS [a]
#VreadLn           :: Read a => IO a
#VreadParen        :: Bool -> ReadS a -> ReadS a
#Vreads            :: Read a => ReadS a #&reads "1 2" :: [(Int,String)] = [(1," 2")]
#VreadsPrec        :: Read a => Int -> ReadS a
#VrealToFrac       :: (Real a, Fractional b) => a -> b
#Vrecip            :: Fractional a => a -> a 
#Vrem              :: Integral a => a -> a -> a 
#Vrepeat           :: a -> [a] #&repeat 'a' = "aaaaaaaaa..."
#Vreplicate        :: Int -> a -> [a] #&replicate 4 'a' = "aaaa"
#Vreturn           :: Monad m => a -> m a 
#Vreverse          :: [a] -> [a] #&reverse "abc" = "cba"
#Vround            :: (RealFrac a, Integral b) => a -> b 
#VscaleFloat       :: RealFloat a => Int -> a -> a 
#Vscanl            :: (a -> b -> a) -> a -> [b] -> [a] #&scanl (+) 0 [1,2,3] = [0,1,3,6]
#Vscanl1           :: (a -> a -> a) -> [a] -> [a] #&scanl1 (+) [1,2,3] = [1,3,6]
#Vscanr            :: (a -> b -> b) -> b -> [a] -> [b] #&scanr (+) 0 [1,2,3] = [6,5,3,0]
#Vscanr1           :: (a -> a -> a) -> [a] -> [a] #&scanr1 (+) [1,2,3] = [6,5,3]
#Vseq              :: a -> b -> b #&#S6.2
#Vsequence         :: Monad m => [m a] -> m [a] 
#Vsequence_        :: Monad m => [m a] -> m () #&do operations in sequence
#Vshow             :: Show a => a -> String #&#S6.3.3
#VshowChar         :: Char -> ShowS
#VshowList         :: Show a => [a] -> ShowS
#VshowParen        :: Bool -> ShowS -> ShowS
#VshowString       :: String -> ShowS
#Vshows            :: Show a => a -> ShowS #&#S6.3.3
#VshowsPrec        :: Show a => Int -> a -> ShowS #&#S6.3.3
#Vsignificand      :: RealFloat a => a -> a 
#Vsignum           :: Num a => a -> a 
#Vsin              :: Floating a => a -> a 
#Vsinh             :: Floating a => a -> a 
#Vsnd              :: (a, b) -> b
#Vspan             :: (a -> Bool) -> [a] -> ([a], [a]) #&span isAlpha "ab cd" = ("ab"," cd")
#VsplitAt          :: Int -> [a] -> ([a], [a]) #&splitAt 2 "abcdef" = ("ab","cdef")
#Vsqrt             :: Floating a => a -> a 
#Vsubtract         :: Num a => a -> a -> a
#Vsucc             :: Enum a => a -> a #&succ False = True
#Vsum              :: Num a => [a] -> a #&sum [1,2,3] = 6
#Vtail             :: [a] -> [a] #&tail "abc" = "bc"
#Vtake             :: Int -> [a] -> [a] #&take 3 "abcde" = "abc"
#VtakeWhile        :: (a -> Bool) -> [a] -> [a] #&takeWhile (> 2) [3,2,1] = [3]
#Vtan              :: Floating a => a -> a 
#Vtanh             :: Floating a => a -> a 
#VtoEnum           :: Enum a => Int -> a #&toEnum 0 :: Bool = False
#VtoInteger        :: Integral a => a -> Integer 
#VtoRational       :: Real a => a -> Rational 
#Vtruncate         :: (RealFrac a, Integral b) => a -> b 
#Vuncurry          :: (a -> b -> c) -> ((a, b) -> c)
#Vundefined        :: a #&#S3.1
#Vunlines          :: [String] -> String
#Vuntil            :: (a -> Bool) -> (a -> a) -> a -> a #&until (> 3) (+ 2) 0 = 4
#Vunwords          :: [String] -> String
#Vunzip            :: [(a, b)] -> ([a], [b]) #&unzip [('a','b'),('c','d')] = ("ac",bd")
#Vunzip3           :: [(a, b, c)] -> ([a], [b], [c])
#VuserError        :: String  -> IOError
#Vwords            :: String -> [String] #&words "ab d as+3" = ["ab","d","as+3"]
#VwriteFile        :: FilePath -> String -> IO ()
#Vzip              :: [a] -> [b] -> [(a, b)] #&zip "abc" "de" = [('a','d'), ('b',e')]
#Vzip3             :: [a] -> [b] -> [c] -> [(a, b, c)]
#VzipWith          :: (a -> b -> c) -> [a] -> [b] -> [c] #&zipWith (+) [1,2] [3,4] = [4,6]
#VzipWith3         :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
#endtable
</table>
