\section{@Foreign.C.Error@}
\label{sec:CError}

The module @Foreign.C.Error@ facilitates C-specific error handling of @errno@.  In
Haskell, we represent values of @errno@ by
%
\begin{quote}
\begin{verbatim}
newtype Errno = Errno CInt
\end{verbatim}
\end{quote}
%
which has an instance for the type class @Eq@.  The implementation of
@Errno@ is disclosed on purpose.  Different operating systems and/or C
libraries often support different values of @errno@.  This module defines
the common values, but due to the open definition of @Errno@ users may
add definitions which are not predefined.  The predefined values are the
following:
%
\begin{quote}
\begin{verbatim}

eOK, e2BIG, eACCES, eADDRINUSE, eADDRNOTAVAIL, eADV,
  eAFNOSUPPORT, eAGAIN, eALREADY, eBADF, eBADMSG, eBADRPC,
  eBUSY, eCHILD, eCOMM, eCONNABORTED, eCONNREFUSED,
  eCONNRESET, eDEADLK, eDESTADDRREQ, eDIRTY, eDOM, eDQUOT,
  eEXIST, eFAULT, eFBIG, eFTYPE, eHOSTDOWN, eHOSTUNREACH,
  eIDRM, eILSEQ, eINPROGRESS, eINTR, eINVAL, eIO, eISCONN,
  eISDIR, eLOOP, eMFILE, eMLINK, eMSGSIZE, eMULTIHOP,
  eNAMETOOLONG, eNETDOWN, eNETRESET, eNETUNREACH, eNFILE,
  eNOBUFS, eNODATA, eNODEV, eNOENT, eNOEXEC, eNOLCK,
  eNOLINK, eNOMEM, eNOMSG, eNONET, eNOPROTOOPT, eNOSPC,
  eNOSR, eNOSTR, eNOSYS, eNOTBLK, eNOTCONN, eNOTDIR,
  eNOTEMPTY, eNOTSOCK, eNOTTY, eNXIO, eOPNOTSUPP, ePERM,
  ePFNOSUPPORT, ePIPE, ePROCLIM, ePROCUNAVAIL,
  ePROGMISMATCH, ePROGUNAVAIL, ePROTO, ePROTONOSUPPORT,
  ePROTOTYPE, eRANGE, eREMCHG, eREMOTE, eROFS, eRPCMISMATCH,
  eRREMOTE, eSHUTDOWN, eSOCKTNOSUPPORT, eSPIPE, eSRCH,
  eSRMNT, eSTALE, eTIME, eTIMEDOUT, eTOOMANYREFS, eTXTBSY,
  eUSERS, eWOULDBLOCK, eXDEV
  :: Errno
\end{verbatim}
\end{quote}
%
The meaning of these values corresponds to that of the C constants of the same
name with the leading "e" converted to upper-case.

The module @Foreign.C.Error@ provides the following functions:
%
\begin{codedesc}
\item[isValidErrno ::\ Errno -> Bool] Yield @True@ if the given
  @Errno@ value is valid on the system.  This implies that the @Eq@
  instance of @Errno@ is also system dependent as it is only defined for
  valid values of @Errno@.

\item[getErrno ::\ IO Errno] Get the current value of @errno@.

\item[resetErrno ::\ IO ()] Reset @errno@ to @eOK@.
  
\item[errnoToIOError ::\ String -> Errno -> Maybe Handle -> Maybe String]
\item[~~~~~~~~~~~~~~~-> Maybe String -> IOError]\combineitems
  Compute a Haskell I/O error based on the given @Errno@
  value.  The first argument to the function should specify the location where
  the error occurred and the third and fourth can be used to specify a file
  handle and filename in the course of whose manipulation the error occurred.
  This is optional information, which can be used to improve the accuracy of
  error messages.
  
\item[throwErrno ::\ String -> IO a] Apply @errnoToIOError@ to the value
  currently returned by @getErrno@.  Its first argument specifies the
  location---no extra information about a file handle or filename can be
  provided in this case.

\item[throwErrnoIf~~:: (a -> Bool) -> String -> IO a -> IO a]
\item[throwErrnoIf\_~:: (a -> Bool) -> String -> IO a -> IO ()]\combineitems
  Behave like @throwErrno@ in case that the result of the @IO@
  action fulfils the predicate passed as a first argument.  The second variant
  discards the result after error handling.

\item[throwErrnoIfRetry~~:: (a -> Bool) -> String -> IO a -> IO a]
\item[throwErrnoIfRetry\_~:: (a -> Bool) -> String -> IO a -> IO ()]%
\combineitems Like @throwErrnoIf@ and @throwErrnoIf_@, but retry
the @IO@ action when it yields the error code @eINTR@---this amounts
to the standard retry loop for interrupted POSIX system calls.

\item[throwErrnoIfMinus1~~:: Num a => String -> IO a -> IO a]
\item[throwErrnoIfMinus1\_~:: Num a => String -> IO a -> IO ()]\combineitems
  Instantiate @throwErrnoIf@ and @throwErrnoIf_@ with the predicate
  @(== -1)@.

\item[throwErrnoIfMinus1Retry~~:: Num a => String -> IO a -> IO a]
\item[throwErrnoIfMinus1Retry\_~:: Num a => String -> IO a -> IO ()]%
  \combineitems Instantiate @throwErrnoIfRetry@ and
  @throwErrnoIfRetry_@ with the predicate @(== -1)@.

\item[throwErrnoIfNull~~~~~~:: String -> IO (Ptr a) -> IO (Ptr a)]
\item[throwErrnoIfNullRetry~:: String -> IO (Ptr a) -> IO (Ptr a)]%
  \combineitems Instantiate @throwErrnoIf@ and @throwErrnoIfRetry@
  with the predicate @(== Ptr.nullPtr)@.
\end{codedesc}
