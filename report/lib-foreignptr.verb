\section{@Foreign.ForeignPtr@}
\label{sec:ForeignPtr}

The type @ForeignPtr@ represents references to objects that are
maintained in a foreign language, i.e., objects that are not part of the data
structures usually managed by the Haskell storage manager.  The type
@ForeignPtr@ is parameterised in the same way as @Ptr@ (cf.\ 
Section~\ref{sec:Ptr}), but in contrast to vanilla memory references of type
@Ptr@, @ForeignPtr@s may be associated with finalizers.  A finalizer
is a routine that is invoked when the Haskell storage manager detects
that---within the Haskell heap and stack---there are no more references left
that are pointing to the @ForeignPtr@.  Typically, the finalizer will
free the resources bound by the foreign object.  Finalizers are generally
implemented in the foreign language\footnote{Finalizers in Haskell cannot be
  safely realised without requiring support for
  concurrency~\cite{boehm:finalizers}.} and have either of the following two
Haskell types:
%
\bprog
@
type FinalizerPtr        a = FunPtr (           Ptr a -> IO ())
type FinalizerEnvPtr env a = FunPtr (Ptr env -> Ptr a -> IO ())
@
\eprog
%
A foreign finalizer is represented as a pointer to a C function of type
@Ptr a -> IO ()@ or a C function of type @Ptr env -> Ptr a -> IO ()@, where @Ptr env@ represents an optional environment passed to the
finalizer on invocation.  That is, a foreign finalizer attached to a finalized
pointer @ForeignPtr a@ gets the finalized pointer in the form of a raw
pointer of type @Ptr a@ as an argument when it is invoked.  In addition,
a foreign finalizer of type @FinalizerEnvPtr env a@ also gets an
environment pointer of type @Ptr env@.  There is no guarantee on how soon
the finalizer is executed after the last reference to the associated foreign
pointer was dropped; this depends on the details of the Haskell storage
manager.  The only guarantee is that the finalizer runs before the program
terminates.  Whether a finalizer may call back into the Haskell system is
system dependent.  Portable code may not rely on such callbacks.

Foreign finalizers that expect an environment are a means to model closures in
languages that do not support them natively, such as C.  They recover part of
the convenience lost by requiring finalizers to be defined in the foreign
languages rather than in Haskell.

The data type @ForeignPtr@ and associated operations have the following
signature and purpose:
%
\begin{codedesc}
\item[data ForeignPtr a] A value of type @ForeignPtr a@ represents a
  pointer to an object, or an array of objects, which may be marshalled to or
  from Haskell values of type @a@.  The type @a@ will normally be an
  instance of class @Storable@ (see Section~\ref{sec:Storable}), which
  provides the marshalling operations.
  
  Instances for the classes @Eq@, @Ord@, and @Show@ are
  provided.  Equality and ordering of two foreign pointers are the same as for
  the plain pointers obtained with @unsafeForeignPtrToPtr@ from those
  foreign pointers.
  
\item[newForeignPtr\_ ::\ Ptr a -> IO (ForeignPtr a)]
  Turn a plain memory reference into a foreign pointer that may be associated
  with finalizers by using @addForeignPtrFinalizer@.
  
\item[newForeignPtr ::\ FinalizerPtr a -> Ptr a -> IO (ForeignPtr a)] This is
  a convenience function that turns a plain memory reference into a foreign
  pointer and immediately adds a finalizer.  It is defined as
  %
\bprog
@
newForeignPtr finalizer ptr = 
  do
    fp <- newForeignPtr_ ptr
    addForeignPtrFinalizer finalizer fp
    return fp
@
\eprog
   
\item[newForeignPtrEnv ::\ FinalizerEnvPtr env a -> Ptr env -> Ptr a -> IO
  (ForeignPtr a)] This variant of @newForeignPtr@ adds a finalizer that
  expects an environment in addition to the finalized pointer.  The
  environment that will be passed to the finalizer is fixed by the second
  argument to @newForeignPtrEnv@.

\item[addForeignPtrFinalizer ::\ FinalizerPtr a -> ForeignPtr a -> IO
  ()] Add a finalizer to the given foreign pointer.  All finalizers
  associated with a single foreign pointer are executed in the opposite order
  of their addition---i.e., the finalizer added last will be executed first.
  
\item[addForeignPtrFinalizerEnv ::\ FinalizerEnvPtr env a -> Ptr env ->
  ForeignPtr a]
\item[~~~~~~~~~~~~~~~~~~~~~~~~~~-> IO ()]\combineitems Add a finalizer that
  expects an environment to an existing foreign pointer.

\item[mallocForeignPtr ::\ Storable a => IO (ForeignPtr a)] Allocate a block
  of memory that is sufficient to hold values of type @a@.  The size of
  the memory area is determined by the function @Storable.sizeOf@
  (Section~\ref{sec:Storable}).  This corresponds to
  @Foreign.Marshal.Alloc.malloc@ (Section~\ref{sec:MarshalAlloc}), but
  automatically attaches a finalizer that frees the block of memory as soon as
  all references to that block of of memory have been dropped.  It is
  \emph{not} guaranteed that the block of memory was allocated by
  @Foreign.Marshal.Alloc.malloc@; so, @Foreign.Marshal.Alloc.realloc@ must not be
  applied to the resulting pointer.

\item[mallocForeignPtrBytes ::\ Int -> IO (ForeignPtr a)] Allocate a block of
  memory of the given number of bytes with a finalizer attached that frees the
  block of memory as soon as all references to that block of memory have
  been dropped.  As for @mallocForeignPtr@, @Foreign.Marshal.Alloc.realloc@
  must not be applied to the resulting pointer.

\item[mallocForeignPtrArray~ ::\ Storable a => Int -> IO (ForeignPtr a)]
\item[mallocForeignPtrArray0 ::\ Storable a => Int -> IO (ForeignPtr a)]%
  \combineitems These functions correspond to @Foreign.Marshal.Array@'s
  @mallocArray@ and @mallocArray0@, respectively, but yield a memory
  area that has a finalizer attached that releases the memory area.  As with
  the previous two functions, it is not guaranteed that the block of memory
  was allocated by @Foreign.Marshal.Alloc.malloc@.
  
\item[withForeignPtr ::\ ForeignPtr a -> (Ptr a -> IO b) -> IO b]
  This is a way to obtain the pointer living inside a foreign pointer. This
  function takes a function which is applied to that pointer. The resulting
  @IO@ action is then executed. The foreign pointer is kept alive at least
  during the whole action, even if it is not used directly inside. Note that
  it is not safe to return the pointer from the action and use it after the
  action completes.  All uses of the pointer should be inside the
  @withForeignPtr@ bracket.

  More precisely, the foreign pointer may be finalized after
  @withForeignPtr@ is finished if the first argument was the last
  occurrence of that foreign pointer.  Finalisation of the foreign pointer
  might render the pointer that is passed to the function useless.
  Consequently, this pointer cannot be used safely anymore after the
  @withForeignPtr@ is finished, unless the function
  @touchForeignPtr@ is used to explicitly keep the foreign pointer alive.
  
  This function is normally used for marshalling data to or from the object
  pointed to by the @ForeignPtr@, using the operations from the
  @Storable@ class.

\item[unsafeForeignPtrToPtr ::\ ForeignPtr a -> Ptr a]
  Extract the pointer component of a foreign pointer. This is a potentially
  dangerous operation.  If the argument to @unsafeForeignPtrToPtr@ is the
  last usage occurrence of the given foreign pointer, then its finalizer(s)
  will be run, which potentially invalidates the plain pointer just obtained.
  Hence, @touchForeignPtr@ must be used wherever it has to be guaranteed
  that the pointer lives on---i.e., has another usage occurrence.
  
  It should be noticed that this function does not need to be monadic when
  used in combination with @touchForeignPtr@.  Until the
  @unsafeForeignPtrToPtr@ is executed, the thunk representing the
  suspended call keeps the foreign pointer alive.  Afterwards, the
  @touchForeignPtr@ keeps the pointer alive.
  
  To avoid subtle coding errors, hand written marshalling code should
  preferably use the function @withForeignPtr@ rather than
  @unsafeForeignPtrToPtr@ and @touchForeignPtr@. However, the later
  routines are occasionally preferred in tool-generated marshalling code.
  
\item[touchForeignPtr ::\ ForeignPtr a -> IO ()] Ensure that the foreign
  pointer in question is alive at the given place in the sequence of @IO@
  actions. In particular, @withForeignPtr@ does a @touchForeignPtr@
  after it executes the user action.
  
  This function can be used to express liveness dependencies between
  @ForeignPtr@s: For example, if the finalizer for one @ForeignPtr@
  touches a second @ForeignPtr@, then it is ensured that the second
  @ForeignPtr@ will stay alive at least as long as the first. This can be
  useful when you want to manipulate interior pointers to a foreign structure:
  You can use @touchForeignPtr@ to express the requirement that the
  exterior pointer must not be finalized until the interior pointer is no
  longer referenced.
    
\item[castForeignPtr ::\ ForeignPtr a -> ForeignPtr b] Cast a
  @ForeignPtr@ parameterised by one type into another type.
\end{codedesc}
