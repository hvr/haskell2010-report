%
% $Header: /home/cvs/root/haskell-report/report/syntax-iso.verb,v 1.3 2001/08/14 07:48:25 simonpj Exp $
%
%**<title>Haskell 98 Syntax</title>
%*section B
%**~header
\section{Syntax}
\label{syntax}
\index{syntax}

\subsection{Notational Conventions}

These notational conventions are used for presenting syntax:

\[\ba{cl}
"[pattern]"		& \tr{optional} \\
"\{pattern\}"		& \tr{zero or more repetitions} \\
"(pattern)"		& \tr{grouping} \\
"pat_1 | pat_2"		& \tr{choice} \\
"pat_{\langle{}pat'\rangle{}}"	& \tr{difference---elements generated by "pat"} \\
			& \tr{except those generated by "pat'"} \\
"@fibonacci@"		& \tr{terminal syntax in typewriter font}
\ea\]

BNF-like syntax is used throughout, with productions having the form:
@@@
nonterm		-> alt_1 | alt_2 | ... | alt_n
@@@

There are some families of nonterminals indexed by
precedence levels (written as a superscript).  Similarly, the
nonterminals "op", "varop", and "conop" may have a double index:
a letter "l", "r", or "n" for left-, right- or nonassociativity and
a precedence level.  A precedence-level variable "i" ranges from 0 to 9;
an associativity variable "a" varies over "\{l, r, n\}".
Thus, for example
@@@
aexp	->  @(@ exp^{i+1} qop^{(a,i)} @)@
@@@
actually stands for 30 productions, with 10 substitutions for "i"
and 3 for "a".

In both the lexical and the context-free syntax, there are some
ambiguities that are to be resolved by making grammatical phrases as
long as possible, proceeding from left to right (in shift-reduce
parsing, resolving shift/reduce conflicts by shifting).  In the lexical
syntax, this is the ``maximal munch'' rule\index{maximal munch rule}.  In the
context-free syntax, this means that conditionals, let-expressions, and
lambda abstractions extend to the right as far as possible.

% here we input a list of the main changes in version 1.1
% \input{syntax-changes-11}

%*anchor on
\subsection{Lexical Syntax}

% This covers only part of the lexical syntax.  The rest is directly
% included since it is much more scattered.

\input{syntax-lexical}

@@@
varid	-> (small \{small | large | digit | @'@ \})_{\langle{}reservedid\rangle{}}
conid		-> large \{small | large | digit | @'@ \} 
reservedid -> @case@ | @class@ | @data@ | @default@ | @deriving@ | @do@ | @else@
	| @if@ | @import@ | @in@ | @infix@ | @infixl@ | @infixr@ | @instance@
	| @let@ | @module@ | @newtype@ | @of@ | @then@ | @type@ | @where@ | @_@
specialid -> @as@ | @qualified@ | @hiding@

varsym		-> ( symbol \{symbol | @:@\} )_{\langle{}reservedop | dashes\rangle{}}
consym		-> (@:@ \{symbol | @:@\})_{\langle{}reservedop\rangle{}}
reservedop	-> @..@ | @:@ | @::@ | @=@ | @\@ | @|@ | @<-@ | @->@ | {\tt @@} | @~@ | @=>@
specialop       -> @-@ | @!@

varid			&& (\tr{variables})
conid			&& (\tr{constructors})
tyvar	->  varid	& (\tr{type variables})
tycon	->  conid 	& (\tr{type constructors})
tycls	->  conid 	& (\tr{type classes})
modid   ->  conid	& (\tr{modules})

qvarid   -> [ modid @.@ ] varid
qconid   -> [ modid @.@ ] conid
qtycon   -> [ modid @.@ ] tycon
qtycls   -> [ modid @.@ ] tycls
qvarsym  -> [ modid @.@ ] varsym
qconsym  -> [ modid @.@ ] consym

decimal		-> digit\{digit\}
octal		-> octit\{octit\}
hexadecimal	-> hexit\{hexit\}

integer		-> decimal
                |  @0o@ octal | @0O@ octal
                |  @0x@ hexadecimal | @0X@ hexadecimal
float		-> decimal @.@ decimal[(@e@ | @E@)[@-@ | @+@]decimal]

char    ->  @'@ (graphic_{\langle{}@'@ | @\@\rangle{}} | space | escape_{\langle{}@\&@\rangle{}}) @'@
string  ->  @"@ \{graphic_{\langle{}@"@  | @\@\rangle{}} | space | escape | gap\} @"@
escape  ->  @\@ ( charesc | ascii | decimal | @o@ octal | @x@ hexadecimal )
charesc -> @a@ | @b@ | @f@ | @n@ | @r@ | @t@ | @v@ | @\@ | @"@ | @'@ | @&@
ascii   -> @^@cntrl | @NUL@ | @SOH@ | @STX@ | @ETX@ | @EOT@ | @ENQ@ | @ACK@ 
       | @BEL@ | @BS@ | @HT@ | @LF@ | @VT@ | @FF@ | @CR@ | @SO@ | @SI@ | @DLE@ 
       | @DC1@ | @DC2@ | @DC3@ | @DC4@ | @NAK@ | @SYN@ | @ETB@ | @CAN@ 
       | @EM@ | @SUB@ | @ESC@ | @FS@ | @GS@ | @RS@ | @US@ | @SP@ | @DEL@
cntrl   -> ascLarge | @@ | @[@ | @\@ | @]@ | @^@ | @_@
gap     ->  @\@ whitechar \{whitechar\} @\@
@@@
\indexsyn{varid}%
\indexsyn{conid}%
\indexsyn{reservedid}%
\indexsyn{varsym}%
\indexsyn{consym}%
\indexsyn{symbol}%
\indexsyn{reservedop}%
\indexsyn{tyvar}%
\indexsyn{tycon}%
\indexsyn{tycls}%
\indexsyn{modid}%
\indexsyn{qvarid}%
\indexsyn{qconid}%
\indexsyn{qtycon}%
\indexsyn{qtycls}%
\indexsyn{qvarsym}%
\indexsyn{qconsym}%
\indexsyn{decimal}%
\indexsyn{octal}%
\indexsyn{hexadecimal}%
\indexsyn{char}%
\indexsyn{string}%
\indexsyn{escape}%
\indexsyn{charesc}%
\indexsyn{ascii}%
\indexsyn{cntrl}%
\indexsyn{gap}%


\subsection{Layout}
\label{layout}
\index{layout}

Section~\ref{lexemes-layout} gives an informal discussion of the layout
rule. This section defines it more precisely.

The meaning of a Haskell program may depend on its {\em layout}.
The effect of layout on its meaning can be completely described by adding
braces and semicolons in places determined by the layout.  The meaning of
this augmented program is now layout insensitive.

The effect of layout is specified in this section by describing
how to add braces and semicolons to a laid-out program.  The specification
takes the form of a function "L" that performs the translation.
The input to "L" is:
\begin{itemize}
\item 
A stream of tokens as specified by the lexical syntax in the Haskell report,
with the following additional tokens: 
\begin{itemize}
\item If the first token after a @let@, @where@, @do@, or @of@ keyword is not @{@, 
it will be preceded by "\{n\}" where "n" is the indentation of the token. 
\item If the first token of a module is not @{@ or @module@, 
then it will be preceded by "\{n\}" where "n" is the indentation of the token. 
\item The first token on each line (not including tokens already 
annotated) is preceded by "<n>" where "n" is the indentation of the token. 
\end{itemize}

\item A stack of ``layout contexts'', in which each element is either:
\begin{itemize}
\item Zero, indicating that the enclosing context is explicit (i.e. the programmer 
supplied the opening brace. 
If the innermost context is 0, then no layout tokens will be inserted 
until either the enclosing context ends or a new context is pushed. 
\item A positive integer, which is the indentation column of the enclosing layout context. 
\end{itemize}
\end{itemize}

The ``indentation'' of a lexeme is the column number
indicating the start of that lexeme; the indentation of a line is the
indentation of its leftmost lexeme.  To determine the column number,
assume a fixed-width font with this tab convention: tab stops
are 8 characters apart, and a tab character causes the insertion of
enough spaces to align the current position with the next tab stop.
For the purposes of the layout rule, Unicode characters in a source program
are considered to be of the same, fixed, width as an ASCII character.
The first column is designated column 1, not 0.
 
The application
\[
L~tokens~[0]
\]
delivers a layout-insensitive translation of "tokens", where "tokens"
is the result of lexically analysing a module and adding column-number
indicators to it as described above.
The definition of "L" is as follows, where we use ``":"'' as a stream
construction operator, and ``"\emptystr"'' for the empty stream.
\begin{center}
\[\ba{lcll}
     L~ (t:ts)~ (m:ms)       & = & @}@ ~:~ (L~ (t:ts)~ ms)           & \mbox{if}~ \mbox{parse-error}(t)~ (Note~ 1) \\
  \\
     L~ (<n>:ts)~ (m:ms)   & = & @;@ ~:~ (L~ ts~(m:ms))           &\mbox{if}~ m = n \\
                           & = & @}@ ~:~ (L~ (<n>:ts)~ ms)       & \mbox{if}~ n < m \\
                           & = & L~ ts~(m:ms)                   & otherwise \\
     \\
     L~ (@}@:ts)~ (0:ms)     & = & @}@ ~:~ (L~ ts~ms)     &                       (Note~ 2) \\
     \\
     L~ (\{n\}:ts)~ (m:ms)   & = & @{@ ~:~ (L~ ts~(n:m:ms))         & \mbox{if}~n > m,~   (Note~ 3)\\
\\
     L~ (@{@:ts)~ ms         & = & @{@ ~:~ (L~ ts~(0:ms))                   &     (Note~ 4)\\
     \\
     L~ (t:ts)~ ms           & = & t ~:~ (L~ ts~ms)\\
\\
     L~ \emptystr~ [0]		   & = & \emptystr\\
     L~ \emptystr~ (m:ms)	   & = & @}@ ~:~ L~ \emptystr~ ms	   & \mbox{if}~m \neq 0~  (Note~ 5)
\ea\]
\end{center}
\begin{description}
\item[Note 1.] The side condition "\mbox{parse-error}(t)" is to be interpreted as follows: 
if the tokens generated so far by "L" together with the next token "t" 
represent an invalid prefix of the Haskell grammar, and the 
tokens generated so far by "L" followed by the token @}@ 
represent a valid prefix of the Haskell grammar, then "\mbox{parse-error}(t)" is true. 

\item[Note 2.] By matching against 0 for the current layout context, 
we ensure that an explicit close brace can only match an explicit open brace. 

\item[Note 3.] A nested context must be further indented 
than the enclosing context ("n>m"). If not, "L" fails, and the compiler should indicate a
layout error.  An example is:
\bprog
@
  f x = let
	   h y = let
    p z = z
		 in p
	in h
@
\eprog
Here, the definition of @p@ is indented less than the indentation of
the enclosing context, which is set in this case by the definition of @h@.

\item[Note 4.] This clause means that all brace pairs are treated as explicit layout 
contexts, including labelled construction and update (Section~\ref{field-ops}). 
This is a difference 
between this formulation and Haskell 1.4.

\item[Note 5.] At the end of the input, any pending close-braces are inserted. 
It is an error at this point to be within a non-layout context (i.e.~ "m = 0"). 
\end{description}

If none of the rules given above matches, then the algorithm fails. It
can fail for instance when the end of the input is reached, and a
non-layout context is active, since the close brace is missing. Some
error conditions are not detected by the algorithm, although they
could be: for example @let }@.

Note 1 implements the feature that layout processing can be stopped
prematurely by a parse error.  For example
\bprog
@
	let x = e; y = x in e'
@
\eprog
is valid, because it translates to 
\bprog
@
	let { x = e; y = x } in e'
@
\eprog
The close brace is inserted due to the parse error rule above.
Another place where the rule comes into play is at the top level
of a module:
\bprog
@
	module M where
	f x = x
@
\eprog
This translates to
\bprog
@
	module M where {
	f x = x
	}
@
\eprog
The close brace is inserted because otherwise the end of file would
cause a parse error.


\startnewsection
\subsection{Context-Free Syntax}
\label{bnf}
@@@
module -> @module@ modid [exports] @where@ body 
       |  body
body   -> @{@ impdecls @;@ topdecls @}@
	| @{@ impdecls  @}@
	| @{@ topdecls  @}@

impdecls     -> impdecl_1 @;@ ... @;@ impdecl_n 	& \qquad (n>=1)
@@@
\indexsyn{module}%
\indexsyn{body}%
\indexsyn{modid}%
\indexsyn{impdecls}%

@@@
exports	 -> @(@ export_1 @,@ ... @,@ export_n [ @,@ ] @)@ & \qquad (n>=0)

export   -> qvar
	 |  qtycon [@(..)@ | @(@ qcname_1 @,@ ... @,@ qcname_n @)@] & \qquad (n>=0)
	 |  qtycls [@(..)@ | @(@ qvar_1 @,@ ... @,@ qvar_n @)@] & \qquad (n>=0)
         |  @module@ modid
qcname   -> qvar | qcon
@@@
\indexsyn{exports}%
\indexsyn{export}%
\indexsyn{qcname}%

@@@
impdecl   -> @import@ [@qualified@] modid [@as@ modid] [impspec]
	  | 	& (empty declaration)

impspec   -> @(@ import_1 @,@ ... @,@ import_n [ @,@ ] @)@ & \qquad (n>=0)
             |  @hiding@ @(@ import_1 @,@ ... @,@ import_n [ @,@ ] @)@ & \qquad (n>=0)

import    -> var
	  |  tycon [ @(..)@ | @(@ cname_1 @,@ ... @,@ cname_n @)@] & \qquad (n>=1)
	  |  tycls [@(..)@ | @(@ var_1 @,@ ... @,@ var_n @)@] & \qquad (n>=0)
cname     -> var | con
@@@
\indexsyn{impdecl}%
\indexsyn{impspec}%
\indexsyn{import}%
\indexsyn{cname}%

@@@
topdecls -> topdecl_1 @;@ ... @;@ topdecl_n 	& \qquad (n>=0)
topdecl	-> @type@ simpletype @=@ type
	|  @data@ [context @=>@] simpletype @=@ constrs [deriving]
        |  @newtype@ [context @=>@] simpletype @=@ newconstr [deriving]
	|  @class@ [scontext @=>@] tycls tyvar [@where@ cdecls]
	|  @instance@ [scontext @=>@] qtycls inst [@where@ idecls]
	|  @default@ @(@type_1 @,@ ... @,@ type_n@)@ & \qquad (n>=0)
	|  decl
@@@
\indexsyn{topdecls}%
\indexsyn{topdecl}%

@@@
decls	-> @{@ decl_1 @;@ ... @;@ decl_n  @}@		& \qquad (n>=0)
decl	-> gendecl
	|  (funlhs | pat^0) rhs

cdecls	-> @{@ cdecl_1 @;@ ... @;@ cdecl_n  @}@		& \qquad (n>=0)
cdecl	-> gendecl
	|  (funlhs | var) rhs

idecls	-> @{@ idecl_1 @;@ ... @;@ idecl_n  @}@		& \qquad (n>=0)
idecl	-> (funlhs | qfunlhs | var | qvar) rhs
	|						& (empty)

gendecl	-> vars @::@ [context @=>@] type	& (type signature)
	|  fixity [digit] ops 			& (fixity declaration)
	|					& (empty declaration)

ops	-> op_1 @,@ ... @,@ op_n		& \qquad (n>=1)
vars	-> var_1 @,@ ...@,@ var_n		& \qquad (n>=1)
fixity	-> @infixl@ | @infixr@ | @infix@
@@@
\indexsyn{vars}%
\indexsyn{fixity}%
\indexsyn{ops}%
\indexsyn{gendecl}%
\indexsyn{decls}%
\indexsyn{decl}%
\indexsyn{cdecls}%
\indexsyn{cdecl}%
\indexsyn{idecls}%
\indexsyn{idecl}%


@@@
type      -> btype [@->@ type]                    & (\tr{function type})

btype    ->  [btype] atype                        & (\tr{type application})

atype    ->  gtycon
          |  tyvar
          |  @(@ type_1 @,@ ... @,@ type_k @)@ & (\tr{tuple type}, k>=2)
          |  @[@ type @]@                      & (\tr{list type})
          |  @(@ type @)@                      & (\tr{parenthesized constructor})

gtycon    -> qtycon
          |  @()@                              & (\tr{unit type})
          |  @[]@                              & (\tr{list constructor})
          |  @(->)@                            & (\tr{function constructor})
          |  @(,@\{@,@\}@)@                    & (\tr{tupling constructors})

context -> class
        |  @(@ class_1 @,@ ... @,@ class_n @)@		& (n>=0)
class	-> qtycls tyvar			
	|  qtycls @(@ tyvar atype_1 ...  atype_n @)@ & (n>=1)
scontext -> simpleclass
        |  @(@ simpleclass_1 @,@ ... @,@ simpleclass_n @)@		& (n>=0)
simpleclass -> qtycls tyvar			
@@@
\indexsyn{type}%
\indexsyn{btype}%
\indexsyn{atype}%
\indexsyn{gtycon}%
\indexsyn{context}%
\indexsyn{class}%
\indexsyn{simpleclass}%
\indexsyn{scontext}%


@@@
simpletype -> tycon tyvar_1 ... tyvar_k & (k>=0)
constrs	   -> constr_1 @|@ ... @|@ constr_n	& (n>=1)
constr	   -> con [@!@] atype_1 ... [@!@] atype_k	& (\tr{arity} con = k, k>=0)
           |  (btype | @!@ atype) conop (btype | @!@ atype) & (\tr{infix} conop)
           |  con @{@ fielddecl_1 @,@ ... @,@ fielddecl_n @}@ & (n>=0)
newconstr  -> con atype
	   |  con @{@ var @::@ type @}@ 
fielddecl  -> vars @::@ (type | @!@ atype)
deriving   -> @deriving@ (dclass | @(@dclass_1@,@ ... @,@ dclass_n@)@)& (n>=0)
dclass     -> qtycls
@@@
\indexsyn{simpletype}%
\indexsyn{constrs}%
\indexsyn{constr}%
\indexsyn{fielddecl}%
\indexsyn{deriving}%
\indexsyn{dclass}%
\indexsyn{newconstr}%

@@@
inst	-> gtycon
	|  @(@ gtycon tyvar_1 ... tyvar_k @)@	& (k>=0, tyvars \tr{distinct})
	|  @(@ tyvar_1 @,@ ... @,@ tyvar_k @)@	& (k>=2, tyvars \tr{distinct})
	|  @[@ tyvar @]@
	|  @(@ tyvar_1 @->@ tyvar_2 @)@		& tyvar_1 \tr{and} tyvar_2 \tr{distinct}
@@@
\indexsyn{inst}%

@@@
funlhs	->  var apat \{ apat \}
	|   pat^{i+1} varop^{(a,i)} pat^{i+1}
	|   lpat^i varop^{({\rm{}l},i)} pat^{i+1}
	|   pat^{i+1} varop^{({\rm{}r},i)} rpat^i
	|   @(@ funlhs @)@  apat \{ apat \}

qfunlhs	->  qvar apat \{ apat \}
	|   pat^{i+1} qvarop^{(a,i)} pat^{i+1}
	|   lpat^i qvarop^{({\rm{}l},i)} pat^{i+1}
	|   pat^{i+1} qvarop^{({\rm{}r},i)} rpat^i
	|   @(@ qfunlhs @)@ apat \{ apat \}

rhs	->  @=@ exp [@where@ decls]
	|   gdrhs [@where@ decls]

gdrhs	->  gd @=@ exp [gdrhs]

gd	->  @|@ exp^0 
@@@
\indexsyn{funlhs}%
\indexsyn{qfunlhs}%
\indexsyn{rhs}%
\indexsyn{gdrhs}%
\indexsyn{gd}%

@@@
exp	->  exp^0 @::@ [context @=>@] type	& (\tr{expression type signature})
        |   exp^0
exp^i	->  exp^{i+1} [qop^{({\rm{}n},i)} exp^{i+1}]
	|   lexp^i
	|   rexp^i
lexp^i	->  (lexp^i | exp^{i+1}) qop^{({\rm{}l},i)} exp^{i+1}
lexp^6	->  @-@ exp^7
rexp^i	->  exp^{i+1} qop^{({\rm{}r},i)} (rexp^i | exp^{i+1})
exp^{10} ->  @\@ apat_1 ... apat_n @->@ exp	& (\tr{lambda abstraction}, n>=1)
	|   @let@ decls @in@ exp	        & ({\tr{let expression}})
	|   @if@ exp @then@ exp @else@ exp	& (\tr{conditional})
	|   @case@ exp @of@ @{@ alts @}@	& (\tr{case expression})
        |   @do@ @{@ stmts  @}@            & (\tr{do expression})
	|   fexp
fexp	->  [fexp] aexp				& (\tr{function application})
@@@
\indexsyn{exp}%
\index{exp@@"exp^i"}%
\index{lexp@@"lexp^i"}%
\index{rexp@@"rexp^i"}%
\indexsyn{fexp}%

@@@
aexp 	->  qvar				& (\tr{variable})
	|   gcon				& (\tr{general constructor})
	|   literal				
	|   @(@ exp @)@			      & (\tr{parenthesized expression})
	|   @(@ exp_1 @,@ ... @,@ exp_k @)@	& (\tr{tuple}, k>=2)
	|   @[@ exp_1 @,@ ... @,@ exp_k @]@	& (\tr{list}, k>=1)
	|   @[@ exp_1 [@,@ exp_2] @..@ [exp_3] @]@ & (\tr{arithmetic sequence})
	|   @[@ exp @|@ qual_1 @,@ ... @,@ qual_n @]@	& (\tr{list comprehension}, n>=1)
	|   @(@ exp^{i+1} qop^{(a,i)} @)@        & (\tr{left section})
        |   @(@ qop^{(a,i)} exp^{i+1} @)@        & (\tr{right section})
        |   qcon @{@ fbind_1 @,@ ... @,@ fbind_n @}@ & (\tr{labeled construction}, n>=0)
        |   aexp_{\{qcon\}} @{@ fbind_1 @,@ ... @,@ fbind_n @}@ & (\tr{labeled update}, n >= 1)
@@@
\indexsyn{aexp}%

@@@
qual	-> pat @<-@ exp 	& (generator)
         | @let@ decls		& (local declaration)
         | exp 			& (guard)

alts	->  alt_1 @;@ ... @;@ alt_n 		& (n>=0)
alt	->  pat @->@ exp [@where@ decls]
	|   pat gdpat [@where@ decls]
	|					& (empty alternative)

gdpat   ->  gd @->@ exp [ gdpat ]

stmts -> stmt_1 ... stmt_n exp [@;@]  & \qquad (n>=0)
stmt -> exp @;@
      | pat @<-@ exp @;@
      | @let@ decls @;@
      | @;@			& (empty statment)

fbind   ->  qvar @=@ exp
        
@@@
\indexsyn{qual}%
\indexsyn{alts}%
\indexsyn{alt}%
\indexsyn{gdpat}%
\indexsyn{stmt}%
\indexsyn{stmts}%
\indexsyn{fbind}%

@@@
pat     ->  var @+@ integer & (\tr{successor pattern})
	|  pat^0
pat^i	->  pat^{i+1} [qconop^{({\rm{}n},i)} pat^{i+1}]
	|   lpat^i
	|   rpat^i
lpat^i	->  (lpat^i | pat^{i+1}) qconop^{({\rm{}l},i)} pat^{i+1}
lpat^6	->  @-@ (integer | float)		& (\tr{negative literal})
rpat^i	->  pat^{i+1} qconop^{({\rm{}r},i)} (rpat^i | pat^{i+1})
pat^{10}->  apat
	|   gcon apat_1 ... apat_k		& (\tr{arity} gcon = k, k>=1)
@@@
\indexsyn{pat}%
\index{pat@@"pat^i"}%
\index{lpat@@"lpat^i"}%
\index{rpat@@"rpat^i"}%
\indexsyn{fpat}%
\indexsyn{fpats}%

@@@
apat	->  var [{\tt @@} apat]			& (\tr{as pattern})
	|   gcon				& (\tr{arity} gcon = 0) 
        |   qcon @{@ fpat_1 @,@ ... @,@ fpat_k @}@ & (\tr{labeled pattern}, k>=0)
	|   literal
	|   @_@					& (\tr{wildcard})
	|   @(@ pat @)@				& (\tr{parenthesized pattern})
	|   @(@ pat_1 @,@ ... @,@ pat_k @)@	& (\tr{tuple pattern}, k>=2)
	|   @[@ pat_1 @,@ ... @,@ pat_k @]@	& (\tr{list pattern}, k>=1) 
	|   @~@ apat				& (\tr{irrefutable pattern})

fpat    ->  qvar @=@ pat
@@@
\indexsyn{apat}%
@@@
gcon    ->  @()@
        |   @[]@
        |   @(,@\{@,@\}@)@
        |   qcon

var	->  varid | @(@ varsym @)@		& (\tr{variable})
qvar	->  qvarid | @(@ qvarsym @)@		& (\tr{qualified variable})
con	->  conid | @(@ consym @)@		& (\tr{constructor})
qcon	->  qconid | @(@ gconsym @)@		& (\tr{qualified constructor})
varop	->  varsym | \bkqB varid \bkqA		& (\tr{variable operator})
qvarop	->  qvarsym | \bkqB qvarid \bkqA	& (\tr{qualified variable operator})
conop	->  consym | \bkqB conid \bkqA		& (\tr{constructor operator})
qconop	->  gconsym | \bkqB qconid \bkqA	& (\tr{qualified constructor operator})
op	->  varop | conop 			& (\tr{operator})
qop     ->  qvarop | qconop			& (\tr{qualified operator})
gconsym ->  @:@ | qconsym
@@@
\indexsyn{gcon}%
\indexsyn{var}%
\indexsyn{qvar}%
\indexsyn{con}%
\indexsyn{qcon}%
\indexsyn{varop}%
\indexsyn{qvarop}%
\indexsyn{conop}%
\indexsyn{qconop}%
\indexsyn{op}%
\indexsyn{qop}%

%*anchor off
% Local Variables: 
% mode: latex
% End:
%**~footer

