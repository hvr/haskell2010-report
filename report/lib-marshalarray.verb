\section{@Foreign.Marshal.Array@}
\label{sec:MarshalArray}

The module @Foreign.Marshal.Array@ provides operations for marshalling Haskell
lists into monolithic arrays and vice versa.  Most functions come in two
flavours: one for arrays terminated by a special termination element and one
where an explicit length parameter is used to determine the extent of an
array.  The typical example for the former case are C's NUL terminated
strings.  However, please note that C strings should usually be marshalled
using the functions provided by @Foreign.C.String@ (Section~\ref{sec:CString}) as
the Unicode encoding has to be taken into account.  All functions specifically
operating on arrays that are terminated by a special termination element have
a name ending on @0@---e.g., @mallocArray@ allocates space for an
array of the given size, whereas @mallocArray0@ allocates space for one
more element to ensure that there is room for the terminator.

The following functions are provided by the module:
%
\begin{codedesc}
\item[mallocArray~~::\ Storable a => Int -> IO (Ptr a)]
\item[allocaArray~~::\ Storable a => Int -> (Ptr a -> IO b) -> IO b]
  \combineitems
\item[reallocArray~::\ Storable a => Ptr a -> Int -> IO (Ptr a)]\combineitems
  The functions behave like the functions @malloc@, @alloca@, and
  @realloc@ provided by the module @Foreign.Marshal.Alloc@
  (Section~\ref{sec:MarshalAlloc}), respectively, except that they allocate a
  memory area that can hold an array of elements of the given length, instead
  of storage for just a single element.

\item[mallocArray0~~::\ Storable a => Int -> IO (Ptr a)]
\item[allocaArray0~~::\ Storable a => Int -> (Ptr a -> IO b) -> IO b]\combineitems
\item[reallocArray0~::\ Storable a => Ptr a -> Int -> IO (Ptr a)]\combineitems
  These functions are like the previous three functions, but reserve storage
  space for one additional array element to allow for a termination indicator.
  
\item[peekArray ::\ Storable a => Int -> Ptr a -> IO {[a]}] Marshal an array of
  the given length and starting at the address indicated by the pointer
  argument into a Haskell list using @Storable.peekElemOff@ to obtain the
  individual elements.  The order of elements in the list matches the order in
  the array.
  
\item[pokeArray ::\ Storable a => Ptr a -> {[a]} -> IO ()] Marshal the elements
  of the given list into an array whose start address is determined by the
  first argument using @Storable.pokeElemOff@ to write the individual
  elements.  The order of elements in the array matches that in the list.
  
\item[peekArray0 ::\ (Storable a, Eq a) => a -> Ptr a -> IO {[a]}] Marshal an
  array like @peekArray@, but instead of the length of the array a
  terminator element is specified by the first argument.  All elements of the
  array, starting with the first element, up to, but excluding the first
  occurrence of an element that is equal (as determined by @==@) to the
  terminator are marshalled.

\item[pokeArray0 ::\ Storable a => a -> Ptr a -> {[a]} -> IO ()]
  Marshal an array like @pokeArray@, but write a terminator value
  (determined by the first argument) after the last element of the list.  Note
  that the terminator must not occur in the marshalled list if it should be
  possible to extract the list with @peekArray0@.

\item[newArray~~::\ Storable a => {[a]} -> IO (Ptr a)]
\item[withArray~::\ Storable a => {[a]} -> (Ptr a -> IO b) -> IO b]\combineitems
  These two functions combine @mallocArray@ and @allocaArray@,
  respectively, with @pokeArray@; i.e., they allocate a memory area for
  an array whose length matches that of the list, and then, marshal the list
  into that memory area.

\item[newArray0~~::\ Storable a => a -> {[a]} -> IO (Ptr a)]
\item[withArray0~::\ Storable a => a -> {[a]} -> (Ptr a -> IO b) -> IO b]\combineitems
  These two functions combine @mallocArray0@ and @allocaArray0@,
  respectively, with the function @pokeArray0@; i.e., they allocate a
  memory area for 
  an array whose length matches that of the list, and then, marshal the list
  into that memory area.  The first argument determines the terminator.

\item[copyArray ::\ Storable a => Ptr a -> Ptr a -> Int -> IO ()]
\item[moveArray ::\ Storable a => Ptr a -> Ptr a -> Int -> IO ()]\combineitems
  These two functions copy entire arrays and behave like the routines
  @Foreign.Marshal.Utils.copyBytes@ and @Foreign.Marshal.Utils.moveBytes@,
  respectively (Section~\ref{sec:MarshalUtils}).  In particular,
  @moveArray@ allows the source and destination array to overlap, whereas
  @copyArray@ does not allow overlapping arrays.  Both functions take a
  reference to the destination array as their first, and a reference to the
  source as their second argument.  However, in contrast to the routines from
  @Foreign.Marshal.Utils@ the third argument here specifies the number of array
  elements (whose type is specified by the parametrised pointer arguments)
  instead of the number of bytes to copy.
  
\item[lengthArray0 ::\ (Storable a, Eq a) => a -> Ptr a -> IO Int] Determine
  the length of an array whose end is marked by the first occurrence of the
  given terminator (first argument). The length is measured in array elements
  (not bytes) and does not include the terminator.
  
\item[advancePtr ::\ Storable a => Ptr a -> Int -> Ptr a] Advance a reference
  to an array by as many array elements (not bytes) as specified.
\end{codedesc}

