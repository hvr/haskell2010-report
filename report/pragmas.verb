%
% $Header: /home/cvs/root/haskell-report/report/pragmas.verb,v 1.1 2001/03/28 14:13:42 simonpj Exp $
%
%**<title>The Haskell 98 Report: Pragmas</title>
%*section E
%**~header
\section{Compiler Pragmas}
\label{pragmas}
\index{pragmas}

Some compiler implementations support compiler {\em pragmas}, which are
used to give additional instructions or hints to the compiler, but which
do not form part of the \Haskell{} language proper and do not change a
program's semantics.  This
section summarizes this existing practice.  An implementation is not
required to respect any pragma, but the pragma should be ignored if an
implementation is not prepared to handle it.  
Lexically, pragmas appear as comments, except that the enclosing
syntax is @{-#@ @#-}@.

\subsection{Inlining}
\index{inlining}
@@@
decl -> @{-#@ @inline@ [digit] qvars @#-}@
decl -> @{-#@ @notInline@ qvars @#-}@
@@@
The optional digit represents the level of optimization at which the
inlining is to occur.  If omitted, it is assumed to be 0.  A compiler
may use a numeric optimization level setting in which increasing level
numbers indicate increasing amounts of optimization.  Trivial
inlinings that have no 
impact on compilation time or code size should have an optimization
level of 0; more complex inlinings that may lead to slow compilation
or large executables should be associated with higher optimization levels.

Compilers will often automatically inline simple expressions.  This
may be prevented by the @notInline@ pragma.

\subsection{Specialization}
@@@
decl -> @{-#@ @specialize@ spec_1 @,@ ... @,@ spec_k @#-}@ & (k>=1)
spec -> vars :: type
@@@
Specialization is used to avoid inefficiencies involved in dispatching
overloaded functions.  For example, in
\bprog
@
factorial :: Num a => a -> a
factorial 0 = 0
factorial n = n * factorial (n-1)
{-# specialize factorial :: Int -> Int,
               factorial :: Integer -> Integer #-}
@
\eprog
calls to @factorial@ in which the compiler can detect that the
parameter is either @Int@ or @Integer@ will
use specialized versions of @factorial@ which do not involve
overloaded numeric operations.

\subsection{Optimization}
@@@
decl -> optdecl
exp^0  -> optdecl exp^0
optdecl -> @{-#@ @optimize@ optd_1 @,@ ... @,@ optd_k @#-}@ & (k >= 1)
optd  -> digit
       | @speed@ digit
       | @space@ digit 
       | @compilationSpeed@ digit
       | @debug@ digit
@@@
The @optimize@ pragma
provides  explicit control over the optimization levels
of the compiler.  If used as a declaration, this applies to all values
defined in the declaration group (and recursively to any nested
values).  Used as an expression, it applies only to the prefixed
expression.  If no attribute is named, the @speed@ attribute is
assumed.

%**~footer
