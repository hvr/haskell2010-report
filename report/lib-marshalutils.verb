\section{@Foreign.Marshal.Utils@}
\label{sec:MarshalUtils}

Finally, the module @Foreign.Marshal.Utils@ provides a set of useful auxiliary
routines. 
%
\begin{codedesc}
\item[new ::\ Storable a => a -> IO (Ptr a)] This function first applies
  @Foreign.Marshal.Alloc.malloc@ (Section~\ref{sec:MarshalAlloc}) to its
  argument, and then, stores the argument in the newly allocated memory area
  using @Foreign.Storable.poke@ (Section~\ref{sec:Storable}).
  
\item[with ::\ Storable a => a -> (Ptr a -> IO b) -> IO b] This function is
  like @new@, but uses @Foreign.Marshal.Alloc.alloca@ instead of
  @Foreign.Marshal.Alloc.malloc@.

\item[fromBool~::\ Num a => Bool -> a]
\item[toBool~~~::\ Num a => a -> Bool]\combineitems These two functions
  implement conversions between Haskell Boolean values and numeric
  representations of Boolean values, where @False@ is represented by
  @0@ and @True@ by any non-zero value.

\item[maybeNew ::\ (a -> IO (Ptr a)) -> (Maybe a -> IO (Ptr a))]
  Lift a function that marshals a value of type @a@ to a function that
  marshals a value of type @Maybe a@.  In case, where the latter is
  @Nothing@, return @Ptr.nullPtr@ (Section~\ref{sec:Ptr})

\item[maybeWith ::\ (a -> (Ptr b -> IO c) -> IO c)%
  -> (Maybe a -> (Ptr b -> IO c) -> IO c)] This function lifts a
  @Foreign.Marshal.Alloc.alloca@ based marshalling function for @a@ to
  @Maybe a@.  It marshals values @Nothing@ in the same way as
  @maybeNew@. 
  
\item[maybePeek ::\ (Ptr a -> IO b) -> (Ptr a -> IO (Maybe b))] Given a
  function that marshals a value stored in the referenced memory area to a
  value of type @b@, lift it to producing a value of type @Maybe b@.
  If the pointer is @Ptr.nullPtr@, produce @Nothing@.
  
% Move to `Data.List.withMany' in new library spec.
%\item[withMany ::\ (a -> (b -> res) -> res) -> {[a]} -> ({[b]} -> res) -> res]
%  Lift a marshalling function of the @with@ family to operate on a list
%  of values.

\item[copyBytes ::\ Ptr a -> Ptr a -> Int -> IO ()]
\item[moveBytes ::\ Ptr a -> Ptr a -> Int -> IO ()]\combineitems These two
  functions are Haskell variants of the standard C library routines
  @memcpy()@ and @memmove()@, respectively.  As with their C
  counterparts, @moveBytes@ allows the source and destination array to
  overlap, whereas @copyBytes@ does not allow overlapping areas.  Both
  functions take a reference to the destination area as their first, and a
  reference to the source as their second argument---i.e., the argument order
  is as in an assignment.
\end{codedesc}
