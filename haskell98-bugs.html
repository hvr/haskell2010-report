<html>
<head>
</head>
<HEAD>
<TITLE>Haskell 98: ERRATA</title></head>
</head>
</head>
</head>
</head>
</HEAD>
<BODY>
<div align=center>
<img src="h98.gif" alt="Haskell 98">
</div>

<h1>Errata in the 
<a href="http://haskell.cs.yale.edu/definition/">Haskell 98 Language Report</a></h1>

All references are to the original Haskell 98 Report, dated 1 Feburary 1999.

<ul>
<p><li> <strong>Title page</strong>.  Remove "[editor]" from after John Hughes.

<p><li> <strong>Title page</strong>.  Add the paragraph:
<p>
"Copyright (c) Simon Peyton Jones.
<p>
The authors intend this Report to belong to the entire Haskell 
community, and so we grant permission to copy and
distribute it for any purpose, provided that it is
reproduced in its entireity, including this Notice.  Modified
versions of this Report may also be copied and distributed for any purpose,
provided that the modified version is clearly presented as such,
and that it does not claim to be a definition of the language Haskell 98."

<p><li> [Aug 2001] <strong>Page 2, The Haskell Kernel.</strong>
Replace the entire section with the following:
<p>
"Haskell has adopted many of the convenient syntactic structures
that have become popular
in functional programming.  In this Report, the meaning of such
syntactic sugar is given by translation into simpler constructs.
If these translations are applied exhaustively, the result is a program
written in a small subset of Haskell that we call the Haskell <em>kernel</em>.
<p>
"Though the kernel is not formally specified, it is essentially a
slightly sugared variant of the lambda calculus with a straightforward
denotational semantics.  The translation of each syntactic structure
into the kernel is given as the syntax is introduced.  This modular
design facilitates reasoning about Haskell programs and provides
useful guidelines for implementors of the language."
<p>
(The intent here is to avoid the common misconception that the kernel
is a formally specified thing.)

<p><li> [Sept 2001] <strong>Page 2, Section 1.4, Namespaces; and
Page 7, Section 2.4, Identifiers and operators; and
Page 15, Section 3.2, Variables, Constructors, Operators, and Literals.</strong>  
Remove the first paragraph (about operators), which does not really belong
here, and item 2 of the list (which is related).  
Instead, amplify the remarks in Section 2.4 and 3.2.  This is a presentational
change only.

<p><li> <strong>Page 5, Section 2.2, Lexical program structure; and Appendix B.2, p120.</strong>
Change the production for <em>uniDigit</em> to
<pre>
  uniDigit -> any Unicode decimal digit
</pre>

<p><li> <strong>Page 5, Section 2.2, Lexical program structure; and Appendix B.2, p120.</strong>
Change the production for <em>symbol</em> to:
<pre>
   symbol -> ascSymbol | uniSymbol&lt; special | _ | : | " | ' &gt;
</pre>

<p><li> <strong>Page 5, Section 2.2, Lexical program structure; and Appendix B.2, p120.</strong>
<ul>
<li> Add <em>return</em>, <em>linefeed</em>, and <em>uniWhite</em> to the production for <em>ANY</em>.
<li> Replace the production for <em>lexeme</em> with:
<pre>
  lexeme -> qvarid | qconid | qop | literal | special | reservedop | reservedid
</pre>
</ul>
(These changes, and the next one, justify the productions for <em>program</em> which claims that a program is
a sequence of lexemes and white space.)

<p><li> <strong>Page 7, Section 2.4, Identifiers and operators; and Appendix B.2, p121.</strong>
Add <em>dashes</em> to <em>reservedop</em> in the exclusion set of the
production for <em>varsym</em>.  (This ensures that "<tt>--</tt>" and
"<tt>---</tt>" are not legal lexemes.

<p><li> <strong>Page 9, Section 2.4, Identifiers and operators; and Page 68, Section 5.5.1, Qualified names.</strong>
Move the first paragraph of 5.5.1, and the following table, and the paragraph starting "The qualifier does not change...",
to the end of Section 2.4.  (These paragraphs deal with lexical matters, which do not belong in Chapter 5.)

<p><li> <strong>Page 9, Section 2.6, Character and String Literals.</strong>
In the production for "cntrl" replace "ASClarge" by "ascLarge".

<p><li> [Oct 2001]  <strong>Page 9, Section 2.6, Characters and String Literals; and 
Page 73, Section 6.1.2, Characters and strings</strong>
<ul>
<li> In Section 2.6, delete the last sentence of the third paragraph "Numeric escapes
that are out of range...".
<p>
<li> In Section 6.1.2, replace the first sentence of the section by
<p>
"The character type <tt>Char</tt>
is an enumeration whose values represent Unicode characters [10]."
</ul>
<p>
This change removes the commitment to 16-bit Unicode.  The result is that the Report
is even vaguer than before about the range of Unicode that a compiler is obliged to
accept, but this confusion is in large part Unicode's fault, and is not readily fixed 
in a revision of this nature.

<p><li> <strong>Page 10, Section 2.7, Layout.</strong>
In the middle of the third paragraph, just before the sentence beginning
"A close brace is also inserted...", add the following sentence:
<p>
"If the indentation of the non-brace lexeme immediately 
following a <tt>where</tt>, <tt>let</tt>,
<tt>do</tt> or <tt>of</tt> is less than or equal to the <em>current</em> indentation level,
then instead of starting a layout, an empty list "<tt>{}</tt>" is inserted, and
layout processing occurs for the current level (i.e. insert a semicolon or close brace)."

<p><li> <strong>Page 11, Figures 1 and 2</strong>.  In both figures the signature for <tt>size</tt>
should be
<pre>
  size :: Stack a -> Int
</pre>

<p><li> [July 2001] <strong>Page 12, Section 3, Expressions.</strong>  
Replace the last two sentences of the first paragrah of the section by:
<p>
"Free variables and constructors used in these translations always
refer to entities defined by the <tt>Prelude</tt>.  For example,
``<tt>concatMap</tt>'' used in the translation of list comprehensions
(Section 3.11) means the <tt>concatMap</tt> defined by the
<tt>Prelude</tt>, regardless of what is in scope where the list
comprehension is used."
<p>
(Clarification only.)

<p><li> [Aug 2001] <strong>Page 13, Section 3, Expressions.</strong>
Remove Table 1, and the associated paragraph beginning "As an aid to
understanding...".  (The table causes more confusion than it clears up.)

<p><li> [Apr 2001] <strong>Page 14, Section 3.1, Errors.</strong>  In the first sentence of
the section, after "indistinguishable" add "by a Haskell program".

<p><li> [Apr 2001] <strong>Page 15, Section 3.2, Variables, Constructors, Operators, and Literals.</strong>  
Remove the paragraph starting "Qualified names may only ...", and the following example, and the
concluding paragraph starting "incorrectly uses a qualifier". (This is all covered in 2.4 and 5.5.1.)

<p><li> [Oct 2001] <strong>Page 18, Section 3.7, Lists.</strong>
After the sentence starting "The constructor ":" is reserved solely for list construction...", 
add the new sentence:
<p>
"It is a right-associative operator, with precedence level 5 (Section 4.4.2)."
<p>
(Otherwise this information is found only in the Prelude.)

<p><li> [July 2001] <strong>Page 20, Section 3.10, Arithmetic sequences.</strong>
In the second paragraph, in the sentence "For the type <tt>Integer</tt>,
arithmetic sequences have the following meaning...", replace "type <tt>Integer</tt>"
with "types <tt>Int</tt> and <tt>Integer</tt>".  Remove <tt>Integer</tt> from the 
list in the paragraph following the bulletted list.

<p><li> [Apr 2001] <strong>Page 21, Section 3.11, List Comprehensions; and Page 128.</strong> 
<ul> <li> In the production for "aexp", change the "n >= 0" to "n >= 1".
<li> Remove the production for (empty qualifier)
<li> In the translation box lower down the page, rewrite the translation so
that it does not involve and empty list of qualifiers.  (Unchanged semantics.)
</ul>
This change ensures that there is at least one qualifier in list comprehension,
and no qualifier is empty.  The translation lower down page 23 is then 
not utterly rigorous, because Q can be empty, and when it is there is no preceding
comma, but I reckon it would make matters worse to "fix" it.

<p><li> [Apr 2001] <strong>Page 23, Section 3.14, Do Expressions; 
and Page 128, Appendix B.4, Context Free Syntax.</strong>
<ul>
<li>
Change the production for <em>stmts</em> to read:
<pre>
	stmts -> stmt1 ... stmtn exp [;]	(n>=0)
</pre>
<li> Add "<tt>;</tt>" to the end of each of the four productions for <em>stmt</em>.
</ul>
That is, every list of statements must end in an expression, optionally
followed by a semicolon.

<p><li> [Aug 2001] <strong>Page 24, Section 3.15, Datatypes with Field Labels.</strong>.
Add an example to illustrate the final point in para 2.

<p><li> [Aug 2001] <strong>Page 26, Section 3.15.3, Updates Using Field Labels</strong>.
In the translation box: 
<ul>
<li> replace the first un-subscripted "C" by "C1", and the second by "Cj".
(The "1" and "j" should be subscripts of course!)
<li> Change "b" to "bs" in the "where..." part.
</ul>

<p><li> [Aug 2001] <strong>Page 28, Section 3.17.1, Patterns.</strong>.
Give an example to illustrate an illegal non-linear pattern.

<p><li> [Aug 2001] <strong>Page 31, Section 3.17.2, Informal Semantics of Case Expressions.</strong>
Replace the example at the foot of Page 31, following the paragraph "The guard semantics...",
with the following:
<pre>
    f :: (Int,Int,Int) -> [Int] -> Int
    f ~(x,y,z) [a] | (a == y) = 1
</pre>
(The previous example use boolean and, which is non-strict in its second argument!)

<p><li> [Apr 2001] <strong>Page 31,33, Figures 3 and 4, Semantics of Case Expressions.</strong>
Replace "completely new variable" by "new variable" in these two figures.  (Some clauses
said "new" and some "completely new" which is misleadingly inconsistent.)

<p><li> [Apr 2001] <strong>Page 33, Figure 4, Semantics of Case Expressions Part 2.</strong>
In clause (r) replace "e0" by "v" throughout.

<p><li> [Sept 2001] <strong>Page 36, Section 4.1.2, Syntax of Types.</strong>
First paragraph, last sentence.  After "infix type constructors are not allowed",
add "(other than <tt>(->)</tt>)".

<p><li> [Oct 2001] <strong>Page 38, Section 4.1.2, Algebraic Datatype Declarations.</strong>
Replace the sentence
"Although the tuple, list, and function types have special syntax, they
are not different from user-defined types with equivalent
functionality."
with
<p>
"These special syntactic forms always denote the built-in type constructors
for functions, tuples, and lists, regardless of what is in scope.
In a similar way, the prefix type constructors <tt>(->),</tt>, <tt>[]</tt>, <tt>()</tt>, <tt>(,)</tt>, 
and so on, always denote the built-in type constructors; they 
cannot be qualified, nor mentioned in import or export lists (Section 5).
(Hence the special production, <em>gtycon</em>, above.)
<p>
"Although the tuple and list types have special syntax, their semantics 
is the same as the equivalent user-defined algebraic data types."
<p>
(This stuff is clarification only.)

<p><li> <strong>Page 40, Section 4.2.1, Algebraic Datatype Declarations.</strong>
In the bottom paragraph on the page, before "The context in the data declaration
has no other effect whatsoever" add the following:
<p>
"Pattern matching against <tt>ConsSet</tt> also gives rise to an <tt>Eq a</tt>
constraint.  For example:
<pre>
  f (ConsSet a s) = a
</pre>
the function <tt>f</tt> has inferred type <tt>Eq a => Set a -> a</tt>."

<p><li> <strong>Page 41, Section 4.2.1, subsection Labelled Fields.</strong>
At the end of the subsection, add a new paragraph:
<p>
"The pattern "<tt>F {}</tt>" matches any value built with constructor <tt>F</tt>,
<em>whether or not <tt>F</tt> was declared with record syntax</em>."

<p><li> [Apr 2001] <strong>Page 42, Section 4.2.1, subsection Labelled Fields.</strong>
Change "occurance" to "occurrence" in the translation box at the very end of
the section.

<p><li> <strong>Page 49, Section 4.3.4, Ambiguous Types...</strong>
In the third paragraph from the end of Section 4.3.4, replace "...an ambiguous 
type variable is defaultable if at least one of its classes is a numeric class..."
by "...an ambiguous type variable, v, is defaultable if v appears only in constraints
of the form (C v), where C is a class, and if at least one of its classes is
a numeric class...".
<p>
The new phrase is "if v appears only in constraints of the
form (C v) where C is a class".  Without this condition the rest of the
sentence does not make sense.

<p><li> [Aug 2001] <strong>Page 51, Section 4.4.2, Fixity Declarations.</strong>
<ul>
<li> In the prodution for <em>gendecl</em> change <em>digit</em> to <em>integer</em>.
<li> Make the same change in the syntax at the start of Section 4 and in Appendix B.
<li> After "A fixity declaration gives the fixity and binding
precedence of one or more operators." add the sentence "The <em>integer</em> in a fixity declaration
must be in the range 0 to 9."
</ul>
(Previously, "digit" was used, and it isn't a lexeme.)

<p><li> [Apr 2001] <strong>Page 53, Section 4.4.3.</strong>  Replace "For example, these two function
definitions are equivalent:", and the two lines of code that follow by:
<br>
"For example, these three function definitions are all equivalent:
<pre>
  plus x y z = x+y+z
  x `plus` y = \ z -> x+y+z
  (x `plus` y) z = x+y+z
</pre>"
(This change makes explicit that an infix operator with more than two arguments
can have all of them on the LHS.)

<p><li> [Apr 2001] <strong>Page 54, Section 4.4.3, subsection Function Bindings.</strong>
In the first translation scheme ("The general binding form for functions..."), 
the <em>xn</em> should be <em>xk</em> (suitably subscripted in both cases!),
and all three <em>m</em> subscripts should be <em>n</em>.

<p><li> <strong>Page 57, Section 4.5.3, Context reduction errors.</strong>
The example
<pre>
      f :: (Monad m, Eq (m a)) => a -> m a -> Bool
      f x y = x == return y
</pre>
is wrong; it should read
<pre>
      f x y = return x == y
</pre>

<p><li> [Sept 2001] <strong>Page 58, Section 4.5.5, Momomorphism.</strong>
In the boxed text entitled "The monomorphism restriction", replace
"The usual Hindley-Milner restriction on polymorphism is that only 
type variables free in the environment may be generalized" by
<p>
"The usual Hindley-Milner restriction on polymorphism is that only 
type variables that do not occur free in the environment may be generalized."
<p>
(The sense was backward before.)

<p><li> [May 2001] <strong>Page 62, Section 5, Modules.</strong>
In paragraph 4, add a footnote to the sentence "A multi-module Haskell
program can be converted into a single-module program by ...", namely:
<p>
"There are two minor exceptions to this statement.
First, <tt>default</tt> declarations scope over a single module (Section 4.3.4).
Second, Rule 2 of the monomorphism restriction (Section 4.5.5)
is affected by module boundaries."
<p>
This footnote qualifies the otherwise over-strong statement.

<p><li> [Oct 2001] <strong>Page 64, Section 5.2, Export declarations, numbered items 5 and 6.</strong>
Replace both items with the following:
<p>
"The form `<tt>module M</tt>' abbreviates the set of all entities whose
<em>unqualified</em> name, <em>e</em>, is in scope, and for which the <em>qualified</em> name
<em>M.e</em> is also in scope and refers to the same entity as <em>e</em>.  This set
may be empty.
For example:
<pre>
  module Queue( module Stack, enqueue, dequeue ) where
      import Stack
      ...
</pre>
"Here the module <tt>Queue</tt> uses the module name <tt>Stack</tt> in its export
list to abbreviate all the entities imported from <tt>Stack</tt>.  
<P>
"A module can name its own local definitions in its export
list using its own name in the `<tt>module M</tt>'' syntax, because a local
declaration brings into scope both a qualified and unqualified name. 
For example:
<pre>
  module Mod1( module Mod1, module Mod2 ) where
  import Mod2
  import Mod3
</pre>
"Here module <tt>Mod1</tt> exports all local definitions as well as those
imported from <tt>Mod2</tt> but not those imported from <tt>Mod3</tt>."

It is an error to use <tt>module M</tt> in an export list unless <tt>M</tt> is 
the module bearing the export list, or <tt>M</tt> is imported by at 
least one import declaration (qualified or unqualified).

<p><li> [July 2001] <strong>Page 65, Section 5.2, Export declarations.</strong>
Replace the two paragraphs and code fragment that the numbered list with the following:
<p>
"It makes no difference to an importing module how an entity was 
exported.  For example, a field name <tt>f</tt> from data type <tt>T</tt> may be exported individually
(<tt>f</tt>, item (1) above); or as an explicitly-named member of its data type (<tt>T(f)</tt>, item (2));
or as an implicitly-named member (<tt>T(..)</tt> item(2)); or by exporting an entire
module (<tt>module M</tt>, item (5)).  
<p>
Exports lists are cumulative: the set of entities exported by an export
list is the union of the entities exported by the individual items of the list.
<p>
The <em>unqualified</em> names of the entities exported by a module must all be distinct
(within their respective namespace).  For example
<pre>
  module A ( module B, C.f, g ) where   -- an invalid module
  import qualified B(f,g)
  import qualified C(f)
  g = True
</pre>
There are name clashes in the export list between <tt>B.f</tt> and <tt>C.f</tt> and
between <tt>g</tt> and <tt>B.g</tt> even though there are no name clashes within
module <tt>A</tt>."

<p><li> [July 2001] <strong>Page 65, Section 5.3, Import Declarations, last line.</strong>
Start a new subsection "5.3.1  What is imported" before "Exactly which entities are to
be imported...".

<p><li> [July 2001] <strong>Page 66, Section 5.3, Import Declarations, numbered item 2.</strong>
Delete the two sentences "The hiding clause only applies to unqualified
names...  A hiding clause has no effect....".

<p><li> [Oct 2001] <strong>Page 66, Section 5.3, Import Declarations, numbered item 2.</strong>
Add "It is an error to hide an entity that is not, in fact, exported by
the imported module."

<p><li> [July 2001] <strong>Page 66, Section 5.3.1, Qualified Import.</strong> [This section
becomes 5.3.2.]  Replace the first sentence with:

"For each entity imported under the rules of Section 5.3.1
the top-level environment is extended.  If the import declaration used
the <tt>qualified</tt> keyword, only the qualified name of the entity is
brought into scope.  If the <tt>qualified</tt> keyword is omitted, then both the
qualified and unqualified name of the entity is brought into scope.
Section 5.5.1 describes qualified names in more detail."


<p><li><strong>Page 67, Section 5.3.2, Local aliases</strong>.
The last example in the section should read:
<pre>
	import Foo as A(f)
</pre>

<p><li> [Aug 2001] <strong>Page 68, Section 5.5.1, Qualified names.</strong>
Replace the second example in the first bullet by:
<pre>
  module M where
    M.f x = ...			-- ILLEGAL
    g x = let M.y = x+1 in ...	-- ILLEGAL
</pre>
(This just clarifies that qualifiers aren't legal in local decls either.)

<p><li> <strong>Page 69, Section 5.5.2, Name clashes.</strong>
At the very end of the section, add the following clarification:
<p>
"The name occurring in a type signature or fixity declarations is always
unqualified, and unambiguously refers to another declaration in the
same declaration list (except that the fixity declaration for a class method
can occur at top level --- Section 4.4.2).  For example, the following 
module is legal:
<pre>	
  module F where
    sin :: Float -> Float
    sin x = (x::Float)

    f x = Prelude.sin (F.sin x)
</pre>
The local declaration for <tt>sin</tt> is legal, even though
the <tt>Prelude</tt> function <tt>sin</tt> is implicitly in scope.
The references to 
<tt>Prelude.sin</tt> and <tt>F.sin</tt> must both be qualified to make
it unambigous which <tt>sin</tt> is meant.
However, the unqualified name "<tt>sin</tt>" in the type 
signature in the first line of <tt>F</tt> unambiguously refers to the
local declaration for <tt>sin</tt>."

<p><li> <strong>Page 71, Section 5.6.2, Shadowing Prelude Names.</strong> 
Replace the example at the beginning of the section, and the entire
following paragraph, with the following
"<pre>
  module A( null, nonNull ) where
    import Prelude hiding( null ) 
    null, nonNull :: Int -> Bool
    null    x = x == 0
    nonNull x = not (null x)
</pre>
Module <tt>A</tt> redefines <tt>null</tt>, and contains an unqualified reference
to <tt>null</tt> on the right hand side of <tt>nonNull</tt>.
The latter would be ambiguous without the "<tt>hiding(null)</tt>" on the 
"<tt>import Prelude</tt>" statement.
Every module that imports <tt>A</tt> unqualified, and then makes an unqualified
reference to <tt>null</tt> must also resolve the ambiguous use of <tt>null</tt>
just as <tt>A</tt> does.  Thus there is little danger of accidentally shadowing 
Prelude names."

<p><li> [Aug 2001]  <strong>Page 74, Section 6.1.3, Lists.</strong>  In the last sentence,
after "<tt>Monad</tt>" add ", <tt>Functor</tt>".  (The list type is an instance of <tt>Functor</tt>.)

<p><li> [May 2001]  <strong>Page 74, Section 6.1.4, Tuples.</strong>
Replace the first paragraph of this section with:
<p>
"Tuples are algebraic datatypes with special syntax, as defined
in Section 3.8.  Each tuple type has a single constructor.
All tuples are instances of <tt>Eq</tt>, <tt>Ord</tt>, <tt>Bounded</tt>, <tt>Read</tt>,
<tt>Show</tt> (provided, of course, that all their component types are).
<p>
There is no upper bound on the size of a tuple, but some Haskell
implementations may restrict the size of tuples, and limit the
instances associated with larger tuples.  However, every Haskell
implementation must support tuples up to size 15, together with their instances
for <tt>Eq</tt>, <tt>Ord</tt>, <tt>Bounded</tt>, <tt>Read</tt>, 
and <tt>Show</tt>.  The Prelude and
libraries define tuple functions such as <tt>zip</tt> for tuples up to a size
of 7."

<p><li> [Apr 2001]  <strong>Page 74, Section 6.1.6, Function Types.</strong>
Delete the sentence "Functions are an instance of the <tt>Show</tt> class but not <tt>Read</tt>".

<p><li> [Aug 2001]  <strong>Page 75, Section 6.1.7, The IO and IOError Types.</strong>
In the second sentence, replace "<tt>Show</tt>" by "<tt>Functor</tt>".  
(<tt>IO</tt> is an instance of <tt>Functor</tt>, but not <tt>Show</tt>.)

<p><li>  [Apr 2001] <strong>Page 76, Section 6.3, Standard Haskell classes.</strong>
There is a formatting error in the example.  There should be a new line
after "the declaration of Class Eq is:", and before the sentence beginning
"This declaration gives default method declarations...".

<p><li> [July 2001] <strong>Page 78, Section 6.3.2, The Ord Class.</strong>
Redefine the default methods for <tt>max</tt> and <tt>min</tt> as follows:
<pre>
    max x y | x <= y    =  y
            | otherwise =  x
    min x y | x <= y    =  x
            | otherwise =  y
</pre>
(This change aligns the report with the code given in the Appendix.)

<p><li>  [Apr 2001] <strong>Page 78, Section 6.3.3, The Read and Show Classes.</strong>
After "The <tt>Read</tt> and <tt>Show</tt> classes are used to convert values
to and from strings." add the sentence: 
"The <tt>Int</tt> argument to <tt>showsPrec</tt> and <tt>readsPrec</tt> gives the operator
precedence of the enclosing context (see Appendix D.4)."
(Clarification only.)

<p><li><strong>Page 80, Section 6.3.6, Class Monad.</strong>
Right at the bottom of the page, replace "However, for IO, the fail
method invokes error." by "For IO, the fail method raises a user
exception in the IO monad (see Section 7.3)."

<p><li> [Aug 2001] <strong>Page 82, Section 6.4, Numbers.</strong>In paragraph 2 of 6.4, replace "Rational library"
with "Ratio library".

<p><li> [July 2001] <strong>Page 83, Section 6.4.2, Arithmetic and number-theoretic operations.</strong>
After "The quod, rem, div, and mod class methods satisfy these laws" add "if <tt>y</tt> is non-zero".

<p><li> [Apr 2001] <strong>Page 84, Section 6.4, Fig 7; and bottom of page 86, Section 6.4.6.</strong>
<pre>
    fromRealFrac :: (RealFrac a, Fractional b) => a -> b
</pre>
should be replaced by
<pre>
    realToFrac :: (Real a, Fractional b) => a -> b
</pre>

<p><li><strong>Page 88, Section 7.1, Standard I/O functions.</strong>
In the section "Input functions" replace "the <tt>IOError</tt> value associated
with end-of-file is defined in a library" by "a predicate <tt>isEOFError</tt> that 
identifies this exception is defined in the <tt>IO</tt> library".

<p><li><strong>Page 90, Section 7.3, Exception handling in the IO monad.</strong>
After the first paragraph give the following type signature:
<pre>
  userError :: String -> IOError
</pre>
Also add an index entry for <tt>userError</tt> on this page.
(These changes are purely presentational.)

<p><li> [Apr 2001] <strong>Page 90, Section 7.3, Exception handling in the IO monad.</strong>
After the above signature for <tt>userError</tt>, add the following:
"The <tt>fail</tt> method of the <tt>IO</tt> instance of the <tt>Monad</tt> class (Section 6.3.6) raises a
<tt>userError</tt>, thus:
<pre>
  instance Monad IO where 
    ...bindings for return, (>>=), (>>)

    fail s = ioError (userError s)
</pre>"

<p><li> [Oct 2001] <strong>Page 93, Appendix A, Standard Prelude.</strong>
Replace the fixity declaration for <tt>(:)</tt> by the following comments:
<pre>
-- The (:) operator is built-in syntax, and cannot legally be given
-- a fixtity declaration; but its fixity is given by:
--   infixr 5  :
</pre>


<p><li><strong>Page 94, Appendix A, Standard Prelude, class <tt>Enum</tt>.</strong>
After the default method for <tt>enumFromTo</tt> add
<pre>
  enumFromThen x y = map toEnum [fromEnum x, fromEnum y ..]
</pre>

<p><li><strong>Page 95, Appendix A, Standard Prelude, class <tt>Floating</tt>.</strong>
Add <tt>asin, acos, atan</tt> to the comment giving the list of minimal complete definitions.

<p><li> [Apr 2001] <strong>Page 101, Appendix A, <tt>instance Monad IO</tt>.</strong>
Replace the definition of <tt>fail</tt> in <tt>instance Monad IO</tt> by
<pre>
    fail s = ioError (userError s)
</pre>

<p><li><strong>Page 102, Appendix A, comments immediately before 
<tt>instance Enum Float</tt>.</strong>
Replace "<tt>1.0</tt>" by "<tt>0.95</tt>".

<p><li> [Aug 2001] <strong>Page 101, Appendix A, instance of <tt>Monad IO</tt>.</strong>
Delete defintion for <tt> >> </tt>.  (The default definition will do.)

<p> <li> [Apr 2001] <strong>Page 105, Appendix A.1, line 11.</strong>
In the module header for <tt>PreludeList</tt> replace "<tt>Sum</tt>" by "<tt>sum</tt>".

<p><li><strong>Page 105, Appendix A.1 (PreludeList), line 19.</strong>
Correct the type of <tt>map</tt> to
<pre>
  map :: (a -> b) -> [a] -> [b]
</pre>

<p><li><strong>Page 106, definition of <tt>(!!)</tt>.</strong>
Replace the definition of <tt>(!!)</tt> with the following:
<pre>
    -- List index (subscript) operator, 0-origin
    (!!)                :: [a] -> Int -> a
    xs     !! n | n < 0 =  error "Prelude.!!: negative index"
    []     !! _         =  error "Prelude.!!: index too large"
    (x:_)  !! 0         =  x
    (_:xs) !! n         =  xs !! (n-1)
</pre>
(The original version had the property that <tt>([] !! -100)</tt>
reported "index too large".)

<p><li> [Apr 2001] <strong>Page 107, definition of <tt>scanl1</tt> and <tt>scanr1</tt>.</strong>
Replace the definitions of <tt>scanl1</tt> and <tt>scanr1</tt> with these:
<pre>
scanl            :: (a -> b -> a) -> a -> [b] -> [a]
scanl f q xs     =  q : (case xs of
                            []   -> []
                            x:xs -> scanl f (f q x) xs)

scanl1           :: (a -> a -> a) -> [a] -> [a]
scanl1 f (x:xs)  =  scanl f x xs
scanl1 _ []      =  []

scanr1          :: (a -> a -> a) -> [a] -> [a]
scanr1 f []     =  []
scanr1 f [x]    =  [x]
scanr1 f (x:xs) =  f x q : qs
                   where qs@(q:_) = scanr1 f xs 
</pre>
The effect is to make both functions defined on the empty list.


<p><li> [Apr 2001] <strong>Page 108, definition of <tt>take</tt>, <tt>drop</tt>, and <tt>splitAt</tt>.</strong>
Replace the definitions of <tt>take</tt>, <tt>drop</tt>, and <tt>splitAt</tt> with these:
<pre>
    take                   :: Int -> [a] -> [a]
    take n _      | n <= 0 =  []
    take _ []              =  []
    take n (x:xs)          =  x : take (n-1) xs
    
    drop                   :: Int -> [a] -> [a]
    drop n xs     | n <= 0 =  xs
    drop _ []              =  []
    drop n (_:xs)          =  drop (n-1) xs

    splitAt                  :: Int -> [a] -> ([a],[a])
    splitAt n xs             =  (take n xs, drop n xs)
</pre>
The effect is that all three functions are defined on negative arguments.  This
is a semantic change.

<p><li> [May 2001; showsPrec corrected Sept 2001]  
<strong>Page 115, instances <tt>Show Int</tt> and <tt>Read Int</tt></strong>. 
Replace the instances for <tt>Show Int</tt> and <tt>Read Int</tt> with
<pre>
    instance  Show Int  where
	showsPrec n = showsPrec n . toInteger
	    -- Converting to Integer avoids
	    -- possible difficulty with minInt
    
    instance  Read Int  where
      readsPrec p r = [(fromInteger i, t) | (i,t) <- readsPrec p r]
	    -- Reading at the Integer type avoids
	    -- possible difficulty with minInt
</pre>
The previous definitions (which are simply specifications, remember) failed on minInt.

<p><li> [Oct 2001]  <strong>Page 123, Appendix B.3, Layout</strong>. 
In the first line of the definition of L, replace "if parse-error(t)" by
"if m /= 0 and parse-error(t)".  This checks that the implicitly-added close
brace matches an implicit open brace.

<p><li> [Aug 2001]  <strong>Page 124, Appendix B.3, Layout</strong>. 
Near the end of the sub-section, delete from "Another place where..." to the end of the 
sub-section.  (Note 5 covers the top-level case.)

<p><li> [Oct 2001]  <strong>Page 130, Appendix C, Literate comments</strong>. 
In paragraph 2, replace 
"The program text is recovered
by taking only those lines beginning with "<tt>&gt;</tt>", 
and deleting the first character of each of those lines"
with
<p>
"The program text is recovered
by taking only those lines beginning with "<tt>&gt;</tt>", 
and replacing the leading "<tt>&gt;</tt>" with a space."

<p><li> [May 2001]  <strong>Page 132, Appendix D, Specification of Derived Instances</strong>. 
In numbered item 3, replace 
``(all constructors must by nullary)'' with 
``(all constructors must be nullary)''.

<p><li> [June 2001] <strong>Page 134, Appendix D.4, Derived instances of Read and Show</strong>.
In the displayed equation starting <tt>fst (head (...)) == x</tt>, replace "<tt>r</tt>" by
the empty string, resulting in the following:
<pre>
  head (readsPrec d (showsPrec d x "")) == (x,"")
</pre>
(The old, stronger, equation is simply false.)

<p><li> [Aug 2001]  <strong>Page 138, Appendix E, Compiler pragmas</strong>.
<ul>
<li> Change <tt>inline</tt> to <tt>INLINE</tt>.
<li> Change <tt>notInline</tt> to <tt>NOINLINE</tt>.
<li> Change <tt>specialize</tt> to <tt>SPECIALIZE</tt>.
<li> Remove the optional digit from the <tt>INLINE</tt> pragma, and replace the first para of E.1 by:
<p>
"The <tt>INLINE</tt> pragma instructs the compiler to inline the specified variables
at their use sites.
Compilers will often automatically inline simple expressions.  This
may be prevented by the <tt>NOINLINE</tt> pragma."
<p> <li> Delete the whole of E.3.
</ul>
(These changes simplify the pramga story, and bring it into line with what
is usually implemented.)


<p><li>  [Apr 2001] <strong>Page 141, Bibliograpy</strong>. 
Citation [4] should read "JR Hindley".

<p><li> <strong>Page 141, Bibliograpy</strong>. 
The library report citation [8] is out of date.  It should read:
"Simon Peyton Jones and John Hughes (editors), Standard Libraries for the
Haskell 98 Programming Language, 1 February 1999".

<p><li><strong>Page 147, Index</strong>.  Remove the entry for "monad comprehension".

<p><li> [Apr 2001] <strong>Index of the Haskell 98 Prelude (HTML version only)</strong>
<ul>
<li> Remove <tt>Eval</tt> as a superclass of <tt>Num</tt>
<li> Correct type of <tt>seq</tt> to <tt>seq :: a -> b -> b</tt>.
<li> Correct type of <tt>getLine</tt> to <tt>IO String</tt>
</ul>
</ul>

<hr>
<h1>Errata in the 
<a href="http://haskell.cs.yale.edu/definition/">Haskell 98 Library Report</a></h1>

<ul>
<p><li> <strong>Title page</strong>.  Remove "[editor]" from after John Hughes.

<p><li> <strong>Title page</strong>.  Add the paragraph:
<p>
"Copyright (c) Simon Peyton Jones.
<p>
The authors intend this Report to belong to the entire Haskell 
community, and so we grant permission to copy and
distribute it for any purpose, provided that it is
reproduced in its entireity, including this Notice.  Modified
versions of this Report may also be copied and distributed for any purpose,
provided that the modified version is clearly presented as such,
and that it does not claim to be a definition of the Haskell 98 libraries."

<p><li>  [Apr 2001] <strong>Page 5, Section 2.1, Library <tt>Ratio</tt></strong>.
Replace the definition of <tt>recip</tt> on line 3 by the following
<pre>
    recip (x:%y)        =  y % x
</pre>
The effect of this change is to use the "smart constructor", <tt>%</tt>, instead
doing it by hand.  In particular, an error will be raised if y is zero.

<p><li> [Sept 2001] <strong>Page 13, Section 4.1, Numeric library</strong>.
<ul>
<li> Add specifications for the functions exported by the Numeric library.

<p><li>In <tt>formatRealFloat</tt>, add the following local definitions:
<pre>
    mk0 "" = "0"            -- Used to ensure we print 34.0, not 34.
    mk0 s  = s              -- and 0.34 not .34
    
    mkdot0 "" = ""          -- Used to ensure we print 34, not 34.
    mkdot0 s  = '.' : s
</pre>
    
<li> In the definition of <tt>formatRealFloat</tt>,
<ul> 
<li> in the definition of <tt>doFmt</tt>,
<li> in the <tt>FFFixed</tt> branch of "<tt>case fmt of ...</tt>",
<li> in the <tt>Nothing</tt> branch of "<tt>case  decs of ...</tt>",
replace the entire branch "<tt>Nothing -> ...</tt>" with
<pre>
       Nothing | e >= 0    -> take e (ds ++ repeat '0') ++ mkdot0 (drop e ds)
	       | otherwise -> '0' : mkdot0 (replicate (-e) '0' ++ ds)
</pre>
<li> in the <tt>Just dec</tt> branch, replace "<tt>(if null ls then "0" else ls) ++ (if null rs then "" else '.' : rs)</tt>"
by "<tt>mk0 ls ++ mkdot0 rs</tt>".

<li> also in the <tt>Just dec</tt> branch, replace "<tt>d : '.' : ds</tt>" by "<tt>d : mkdot0 ds</tt>".
</ul>

<p><li>In the definition of <tt>k</tt> in <tt>floatToDigits</tt> replace "<tt>fromInt e</tt>" by "<tt>fromIntegral e</tt>".
(<tt>fromInt</tt> no longer exists.)
<li> Last line of code for <tt>floatToDigits</tt>, replace "<tt>toInt</tt>" by "<tt>fromIntegral</tt>".
(<tt>toInt</tt> no longer exists.)
</ul>


<p><li> [Sept 2001] <strong>Page 16, Section 4, Numeric library</strong>. In the definition
of <tt>readFloat</tt>, after "... <tt>(k,t) <- readExp s]</tt>" add
<pre>
    ++ [ (0/0, t) | ("NaN",t)      <- lex r]
    ++ [ (1/0, t) | ("Infinity",t) <- lex r]
</pre>
(This makes <tt>readFloat</tt> able to read "Infinity" and "NaN", which <tt>formatRealFloat</tt>
can produce.)

<p><li> <strong>Page 17, Section 5, first text line</strong>.  Replace "continuous" by "contiguous".

<p><li> [May 2001] <strong>Page 17, Section 5, Indexing operations</strong>.  
Add the following equation to the laws listed just before Section 5.1:
<pre>
  map index (range (l,u)) == [0..rangeSize (l,u)]
</pre>
This documents an invariant that was previously only implicit.

<p><li> [Oct 2001] <strong>Page 17, Section 5, Indexing operations</strong>.
This significant item makes <tt>rangeSize</tt> into a method of
<tt>Ix</tt> rather than a free-standing declaration.  Though this
change is visible to the programmer, all existing Haskell 98
programs will continue to work.

<ul>
<li>  <strong>Page 17, Section 5, Indexing operations, boxed text</strong>. Replace the <tt>Ix</tt>
change the class declaration, and the type signature for <tt>rangeSize</tt> with:
<pre>
  class Ord a => Ix a where
    range     :: (a,a) -> [a]
    index     :: (a,a) -> a -> Int
    inRange   :: (a,a) -> a -> Bool
    rangeSize :: (a,a) -> Int
</pre>
<li> <strong>Section 5.2, pages 19, line 3</strong>. Replace the <tt>Ix</tt>
class declaration, and the <tt>rangeSize</tt> declaration, with:
<pre>
  class Ord a => Ix a where
    range     :: (a,a) -> [a]
    index     :: (a,a) -> a -> Int
    inRange   :: (a,a) -> a -> Bool
    rangeSize :: (a,a) -> Int

    rangeSize b@(l,h) | null (range b) = 0
                      | otherwise      = index b h + 1 
	-- NB: replacing "null (range b)" by  "not (l <= h)"
	-- fails if the bounds are tuples.  For example,
	-- 	(1,2) <= (2,1)
	-- but the range is nevertheless empty
	--	range ((1,2),(2,1)) = []
</pre>
(Note: the comment has changed too; it was misleading before.)
</ul>

<p><li> [July 2001] <strong>Page 17, Section 5.1, Derived instances of <tt>Ix</tt></strong>.
Replace the first paragraph with the following:
<p>
"It is possible to derive an instance of <tt>Ix</tt> automatically, using
a <tt>deriving</tt> clause on a <tt>data</tt> declaration (Section 4.3.3
of the Language Report).
Such derived instance declarations for the class <tt>Ix</tt> are only possible
for enumerations (i.e. datatypes having
only nullary constructors) and single-constructor datatypes,
whose constituent types are instances of <tt>Ix</tt>.   A Haskell implementation
must provide <tt>Ix</tt> instances for tuples up to at least size 15."
<p>
[This change just clarifies, and propagates the "instances up to size 15" change from 
Section 6.1.6 of the Language Report.]

<p><li> <strong>Page 22, Section 6.3; and Page 23, Fig 3</strong>:
Replace "<tt>map</tt>" by "<tt>fmap</tt>" (two occurrences in 6.3, one in Fig 3).

<p><li> [May 2001] <strong>Page 23, Figure 3</strong>.
In the definition of <tt>diag</tt>, delete the guard ``<tt>| l==l' &amp;&amp; u==u'</tt>''.
(The original intent was presumably to check for a square array, but
 simply makes the definition recursive and hence divergent.)

<p><li> <strong>Page 29, Section 7.2</strong>.  Add a new bullet for <tt>nub</tt>.
Add an index entry for <tt>nub</tt>.

<p><li> <strong>Page 29, Section 7.2, second bullet</strong>.  
Introduce a new bullet just before "<tt>union</tt> is list union".

<p><li> [May 2001] <strong>Page 30, Section 7.4, unfoldr</strong>.
Replace the first line-and-a-half paragraph with:
<p>
"The <tt>unfoldr</tt> function is a `dual' to <tt>foldr</tt>: while <tt>foldr</tt> reduces a list
to a summary value, <tt>unfoldr</tt> builds a list from a seed value.  For 
example:
<pre>
  iterate f == unfoldr (\x -> Just (x, f x))
</pre>
In some cases, <tt>unfoldr</tt> can undo a <tt>foldr</tt> operation:"
<p>
(Followed by the existing displayed equation.)

<p><li> [Apr 2001] <strong>Page 34, Section 7.8, Library List</strong>.
Replace the definition of <tt>partition</tt> by
<pre>
   partition               :: (a -> Bool) -> [a] -> ([a],[a])
   partition p xs          =  (filter p xs, filter (not . p) xs)
</pre>
This simply makes it agree with the definition on page 30 (Section 7.3).

<p><li> [Apr 2001] <strong>Page 35, Section 7.8</strong>.
Replace the definitions of <tt>maximumBy</tt> and <tt>minimumBy</tt> by the following
<pre>
    maximumBy               :: (a -> a -> Ordering) -> [a] -> a
    maximumBy cmp []        =  error "List.maximumBy: empty list"
    maximumBy cmp xs        =  foldl1 max xs
			    where
			       max x y = case cmp x y of
					    GT -> x
					    _  -> y
    
    minimumBy               :: (a -> a -> Ordering) -> [a] -> a
    minimumBy cmp []        =  error "List.minimumBy: empty list"
    minimumBy cmp xs        =  foldl1 min xs
			    where
			       min x y = case cmp x y of
					    GT -> y
					    _  -> x
</pre>
<strong>NOTE:</strong> this is a semantic change, but it makes the definitions
consistent with the other "By" functions, and with the signatures given on page 28.

<p><li><strong>Page 54, Sections 11, 12, 13</strong>.
Replace "<tt>isIllegalOperationError</tt>" with "<tt>isIllegalOperation</tt>" throughout.
Namely:
<ul>
<li> Section 11.1, second para after bullets (two occurrences).
<li> Section 12, para 2 (two occurrences).
<li> Section 13, para 2 (two occurrences).
</ul>
(It was inconsistent before.)  

<p><li><strong>Page 54, Section 11</strong>.
The signature for <tt>try</tt> should be
<pre>
  try :: IO a -> IO (Either IOError a)
</pre>

<p><li> [May 2001] <strong>Page 57, Section 11.2.1 Semi-closed handles</strong>.
Replace the sentence "Once a semi-closed handle becomes closed..." with
"Once a semi-closed handle becomes closed, the contents of the
associated list becomes fixed.  The contents of this final list is
only partially specified: it will contain at least all the items of
the stream that were evalutated prior to the handle becoming closed."
<p>
This change attempts to clarify the (murky) meaning of <tt>hGetContents</tt> followed by
<tt>hClose</tt>.

<p><li> [Apr 2001] <strong>Page 56-58, Section 11.2, Files and Handles</strong>.
Add a section 11.2.3 to clarify the file-locking issue.  It says:
<p>
"Implementations should enforce as far as possible, at least locally to the
Haskell process, multiple-reader single-writer locking on files.
That is, there may either be many handles on the same file which manage
input, or just one handle on the file which manages output.  If any
open or semi-closed handle is managing a file for output, no new
handle can be allocated for that file.  If any open or semi-closed
handle is managing a file for input, new handles can only be allocated
if they do not manage output.  Whether two files are the same is
implementation-dependent, but they should normally be the same if they
have the same absolute path name and neither has been renamed, for
example.

Warning: the <tt>readFile</tt> operation (Section 7.1 of the Haskell Language Report)
holds a semi-closed handle on the file until the entire contents of the file have been
consumed.  It follows that an attempt to write to a file (using <tt>writeFile</tt>, for example)
that was earlier opened by <tt>readFile</tt> will usually result in 
failure with <tt>isAlreadyInUseError</tt>."

<p><li> [May 2001] <strong>Page 59, Section 11.4.2</strong>.
Before "The buffer is emptied as soon as it has been written out." add: 
"An implementation is free to flush the buffer more frequently, but not 
less frequently, than
specified above."  (Clarification only.)

<p><li> [May 2001] <strong>Page 59, Section 11.4.2</strong>.
In the second no-buffering bullet (sixth bullet in the sub-section) add the
sentence: "The <tt>hLookAhead</tt> operation implies that
even a no-buffered handle may require a one-character buffer. "  (Clarification only.)

<p><li><strong>Page 62, Section 11.7.2</strong>.
<ul>
<li>Add a new section heading "<strong>11.7.3 Reading the entire input</strong>"
just before the paragraph about <tt>hGetContents</tt>.  
<li>
Add a new section heading "<strong>11.7.4 Text output</strong>" before the
paragraph about <tt>hPutChar</tt>.
</ul>
<p><li><strong>Page 63, definition of <tt>main</tt> in Section 11.8.1</strong>.
Replace the definition of "<tt>readNum</tt>" with
<pre>
  where readNum :: IO Integer
	-- Need a type signature for readLn to avoid ambiguity
	readNum = readLn
</pre>
(This change merely advertises the generally useful function <tt>readLn</tt>.)


<p><li><strong>Page 64, Section 12, Directory functions.</strong>
(More an editor's blunder than a typo.)
<ul>
<li>
Replace the abstract definition of <tt>Permissions</tt>, and the four instances
of <tt>Permissions</tt> with
<pre>
  data Permissions 
    = Permissions {
        readable, writable, executable, searchable :: Bool
      }
      deriving ( Eq, Ord, Read, Show )
</pre>
<li> Remove <tt>readable, writable, executable, searchable</tt> both from
the module header, and from the module body.
<li> Change <tt>Permissions</tt> to <tt>Permissions(Permissions, readable, writable, executable, searchable)</tt>
in the module header.
</ul>

<p><li> [Apr 2001] <strong>Page 78, Section 16, The <tt>CPUTime</tt> library</strong>.
Add <tt>cpuTimePrecision</tt> to the export list.

<p><li>[Apr 2001] <strong>Page 81, Section 17.1, The <tt>RandomGen</tt> class</strong>.
This sigificant semantic change adds a method <tt>genRange</tt> to the <tt>RandomGen</tt>
class.  (Extensive discussion on the Haskell mailing list made it clear that this change
is essential to make the RandomGen class useful.)  The following summarises the changes
but not in the detailed line-by-line form used for the rest of the errata.
<ul>
<li> Add a method <tt>genRange :: g -> (Int,Int)</tt> to class <tt>RandomGen</tt>.
<li> Give it the default method <tt>genRange g = (minBound,maxBound)</tt>
<li> Add a specification of <tt>genRange</tt>
<li> Change the header on page 80 to match.
</ul>

<p><li>[Apr 2001] <strong>Page 81, Section 17.1, The <tt>RandomGen</tt> class</strong>.
Specify more precisely that <tt>split</tt> must deliver <strong>independent</strong> generators.

<p><li><strong>Page 81, Section 17.1, The <tt>RandomGen</tt> class</strong>.
Bottom line on page 81: replace "<tt>show/Read</tt> instances" with
"<tt>Show/Read</tt> instances" (i.e. capitalise <tt>Show</tt>).

<p><li><strong>Page 83, Section 17.3, The global random number generator</strong>.
In the first paragraph, replace "kernal" by "kernel".

</ul>
<hr>
<address>Simon Peyton Jones, simonpj@microsoft.com</address>
</body>
</html>

