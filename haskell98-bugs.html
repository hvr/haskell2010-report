<html>
<head>
</head>
<HEAD>
<TITLE>Haskell 98: ERRATA</title></head>
</head>
</head>
</head>
</head>
</HEAD>
<BODY>
<div align=center>
<img src="h98.gif" alt="Haskell 98">
</div>

<h1>Errata in the 
<a href="http://haskell.cs.yale.edu/definition/">Haskell 98 Language Report</a></h1>

<ul>
<p><li> <strong>Title page</strong>.  Add the paragraph:
<p>
"Copyright (c) Simon Peyton Jones and John Hughes.
<p>
The authors intend this Report to belong to the entire Haskell 
community, and so we grant permission to copy and
distribute it for any purpose, provided that it is
reproduced in its entireity, including this Notice.  Modified
versions of this Report may also be copied and distributed for any purpose,
provided that the modified version is clearly presented as such,
and that it does not claim to be a definition of the language Haskell 98."

<p><li> <strong>Page 9, Section 2.6, Character and String Literals.</strong>
In the production for "cntrl" replace "ASClarge" by "ascLarge".

<p><li> <strong>Page 10, Section 2.7, Layout.</strong>
In the middle of the third paragraph, just before the sentence beginning
"A close brace is also inserted...", add the following sentence:
<p>
"If the indentation of the non-brace lexeme immediately 
following a <tt>where</tt>, <tt>let</tt>,
<tt>do</tt> or <tt>of</tt> is less than or equal to the <em>current</em> indentation level,
then instead of starting a layout, an empty list "<tt>{}</tt>" is inserted, and
layout processing occurs for the current level (i.e. insert a semicolon or close brace)."

<p><li> <strong>Page 11, Figures 1 and 2</strong>.  In both figures the signature for <tt>size</tt>
should be
<pre>
  size :: Stack a -> Int
</pre>

<p><li> [Apr 2001] <strong>Page 14, Section 3.1, Errors.</strong>  In the first sentence of
the section, after "indistinguishable" add "by a Haskell program".

<p><li> [Apr 2001] <strong>Page 20, Section 3.10, Arithmetic sequences.</strong>
In the second paragraph, in the sentence "For the type <tt>Integer</tt>,
arithmetic sequences have the following meaning...", replace "<tt>Integer</tt>"
with "<tt>Int</tt>".

<p><li> [Apr 2001] <strong>Page 21, Section 3.11, List Comprehensions; and Page 128.</strong> 
<ul> <li> In the production for "aexp", change the "n >= 0" to "n >= 1".
<li> Remove the production for (empty qualifier)
<li> In the translation box lower down the page, rewrite the translation so
that it does not involve and empty list of qualifiers.  (Unchanged semantics.)
</ul>
This change ensures that there is at least one qualifier in list comprehension,
and no qualifier is empty.  The translation lower down page 23 is then 
not utterly rigorous, because Q can be empty, and when it is there is no preceding
comma, but I reckon it would make matters worse to "fix" it.

<p><li> [Apr 2001] <strong>Page 23, Section 3.14, Do Expressions; 
and Page 128, Appendix B.4, Context Free Syntax.</strong>
<ul>
<li>
Change the production for <em>stmts</em> to read:
<pre>
	stmts -> stmt1 ... stmtn exp [;]	(n>=0)
</pre>
<li> Add "<tt>;</tt>" to the end of each of the four productions for <em>stmt</em>.
</ul>
That is, every list of statements must end in an expression, optionally
followed by a semicolon.

<p><li> [Apr 2001] <strong>Page 31,33, Figures 3 and 4, Semantics of Case Expressions.</strong>
Replace "completely new variable" by "new variable" in these two figures.  (Some clauses
said "new" and some "completely new" which is misleadingly inconsistent.)

<p><li> [Apr 2001] <strong>Page 33, Figure 4, Semantics of Case Expressions Part 2.</strong>
In clause (r) replace "e0" by "v" throughout.

<p><li> <strong>Page 40, Section 4.2.1, Algebraic Datatype Declarations.</strong>
In the bottom paragraph on the page, before "The context in the data declaration
has no other effect whatsoever" add the following:
<p>
"Pattern matching against <tt>ConsSet</tt> also gives rise to an <tt>Eq a</tt>
constraint.  For example:
<pre>
  f (ConsSet a s) = a
</pre>
the function <tt>f</tt> has inferred type <tt>Eq a => Set a -> a</tt>."

<p><li> <strong>Page 41, Section 4.2.1, subsection Labelled Fields.</strong>
At the end of the subsection, add a new paragraph:
<p>
"The pattern "<tt>F {}</tt>" matches any value built with constructor <tt>F</tt>,
<em>whether or not <tt>F</tt> was declared with record syntax</em>."

<p><li> [Apr 2001] <strong>Page 42, Section 4.2.1, subsection Labelled Fields.</strong>
Change "occurance" to "occurrence" in the translation box at the very end of
the section.

<p><li> <strong>Page 49, Section 4.3.4, Ambiguous Types...</strong>
In the third paragraph from the end of Section 4.3.4, replace "...an ambiguous 
type variable is defaultable if at least one of its classes is a numeric class..."
by "...an ambiguous type variable, v, is defaultable if v appears only in constraints
of the form (C v), where C is a class, and if at least one of its classes is
a numeric class...".
<p>
The new phrase is "if v appears only in constraints of the
form (C v) where C is a class".  Without this condition the rest of the
sentence does not make sense.

<p><li> [Apr 2001] <strong>Page 53, Section 4.3.3.</strong>  Replace "For example, these two function
definitions are equivalent:", and the two lines of code that follow by:
<br>
"For example, these three function definitions are all equivalent:
<pre>
  plus x y z = x+y+z
  x `plus` y = \ z -> x+y+z
  (x `plus` y) z = x+y+z
</pre>"
(This change makes explicit that an infix operator with more than two arguments
can have all of them on the LHS.)

<p><li> [Apr 2001] <strong>Page 54, Section 4.4.3, subsection Function Bindings.</strong>
In the first translation scheme ("The general binding form for functions..."), 
the <em>xn</em> should be <em>xk</em> (suitably subscripted in both cases!),
and all three <em>m</em> subscripts should be <em>n</em>.

<p><li> <strong>Page 57, Section 4.5.3, Context reduction errors.</strong>
The example
<pre>
      f :: (Monad m, Eq (m a)) => a -> m a -> Bool
      f x y = x == return y
</pre>
is wrong; it should read
<pre>
      f x y = return x == y
</pre>

<p><li> [May 2001] <strong>Page 62, Section 5, Modules.</strong>
In paragraph 4, add a footnote to the sentence "A multi-module Haskell
program can be converted into a single-module program by ...", namely:
<p>
"There are two minor exceptions to this statement.
First, <tt>default</tt> declarations scope over a single module (Section 4.3.4).
Second, Rule 2 of the monomorphism restriction (Section 4.5.5)
is affected by module boundaries."
<p>
This footnote qualifies the otherwise over-strong statement.

<p><li> <strong>Page 66, Section 5.3, Import Declarations, numbered item 2.</strong>
Start a new paragraph before the sentence "The hiding clause only applies to unqualified
names...".

<p><li><strong>Page 67, Section 5.3.2, Local aliases</strong>.
The the last example in the section should read:
<pre>
	import Foo as A(f)
</pre>

<p><li> <strong>Page 69, Section 5.5.2, Name clashes.</strong>
At the very end of the section, add the following clarification:
<p>
"The name occurring in a type signature or fixity declarations is always
unqualified, and unambiguously refers to another declaration in the
same declaration list (except that the fixity declaration for a class method
can occur at top level --- Section 4.4.2).  For example, the following 
module is legal:
<pre>	
  module F where
    sin :: Float -> Float
    sin x = (x::Float)

    f x = Prelude.sin (F.sin x)
</pre>
The local declaration for <tt>sin</tt> is legal, even though
the <tt>Prelude</tt> function <tt>sin</tt> is implicitly in scope.
The references to 
<tt>Prelude.sin</tt> and <tt>F.sin</tt> must both be qualified to make
it unambigous which <tt>sin</tt> is meant.
However, the unqualified name "<tt>sin</tt>" in the type 
signature in the first line of <tt>F</tt> unambiguously refers to the
local declaration for <tt>sin</tt>."

<p><li> <strong>Page 71, Section 5.6.2, Shadowing Prelude Names.</strong> 
Replace the example at the beginning of the section, and the entire
following paragraph, with the following
"<pre>
  module A( null, nonNull ) where
    import Prelude hiding( null ) 
    null, nonNull :: Int -> Bool
    null    x = x == 0
    nonNull x = not (null x)
</pre>
Module <tt>A</tt> redefines <tt>null</tt>, and contains an unqualified reference
to <tt>null</tt> on the right hand side of <tt>nonNull</tt>.
The latter would be ambiguous without the "<tt>hiding(null)</tt>" on the 
"<tt>import Prelude</tt>" statement.
Every module that imports <tt>A</tt> unqualified, and then makes an unqualified
reference to <tt>null</tt> must also resolve the ambiguous use of <tt>null</tt>
just as <tt>A</tt> does.  Thus there is little danger of accidentally shadowing 
Prelude names."

<p><li> [May 2001]  <strong>Page 74, Section 6.1.6, Tuples.</strong>
Replace the first paragraph of this section with:
<p>
"Tuples are algebraic datatypes with special syntax, as defined
in Section 3.8.  Each tuple type has a single constructor.
All tuples are instances of <tt>Eq</tt>, <tt>Ord</tt>, <tt>Bounded</tt>, <tt>Read</tt>,
<tt>Show</tt>, and <tt>Ix</tt> (provided, of course, that all their component types are).
<p>
There is no upper bound on the size of a tuple, but some Haskell
implementations may restrict the size of tuples, and limit the
instances associated with larger tuples.  However, every Haskell
implementation must support tuples up to size 7, and their instances
for <tt>Eq</tt>, <tt>Ord</tt>, <tt>Bounded</tt>, <tt>Read</tt>, 
<tt>Show</tt>, and <tt>Ix</tt>.  The Prelude and
libraries define tuple functions such as <tt>zip</tt> for tuples up to a size
of 7."


<p><li> [Apr 2001]  <strong>Page 74, Section 6.1.6, Function Types.</strong>
Delete the sentence "Functions are an instance of the <tt>Show</tt> class but not <tt>Read</tt>".

<p><li>  [Apr 2001] <strong>Page 76, Section 6.3, Standard Haskell classes.</strong>
There is a formatting error in the example.  There should be a new line
after "the declaration of Class Eq is:", and before the sentence beginning
"This declaration gives default method declarations...".

<p><li>  [Apr 2001] <strong>Page 78, Section 6.3.3, The Read and Show Classes.</strong>
After "The <tt>Read</tt> and <tt>Show</tt> classes are used to convert values
to and from strings." add the sentence: 
"The <tt>Int</tt> argument to <tt>showsPrec</tt> and <tt>readsPrec</tt> gives the operator
precedence of the enclosing context (see Appendix D.4)."
(Clarification only.)

<p><li><strong>Page 80, Section 6.3.6, Class Monad.</strong>
Right at the bottom of the page, replace "However, for IO, the fail
method invokes error." by "For IO, the fail method raises a user
exception in the IO monad (see Section 7.3)."

<p><li> [Apr 2001] <strong>Page 84, Section 6.4, Fig 7; and bottom of page 86, Section 6.4.6.</strong>
<pre>
    fromRealFrac :: (RealFrac a, Fractional b) => a -> b
</pre>
should be replaced by
<pre>
    realToFrac :: (Real a, Fractional b) => a -> b
</pre>

<p><li><strong>Page 90, Section 7.3, Exception handling in the IO monad.</strong>
After the first paragraph give the following type signature:
<pre>
  userError :: String -> IOError
</pre>
Also add an index entry for <tt>userError</tt> on this page.
(These changes are purely presentational.)

<p><li> [Apr 2001] <strong>Page 90, Section 7.3, Exception handling in the IO monad.</strong>
After the above signature for <tt>userError</tt>, add the following:
"The <tt>fail</tt> method of the <tt>IO</tt> instance of the <tt>Monad</tt> class (Section 6.3.6) raises a
<tt>userError</tt>, thus:
<pre>
  instance Monad IO where 
    ...bindings for return, (>>=), (>>)

    fail s = ioError (userError s)
</pre>"

<p><li><strong>Page 94, Appendix A, Standard Prelude, class <tt>Enum</tt>.</strong>
After the default method for <tt>enumFromTo</tt> add
<pre>
  enumFromThen x y = map toEnum [fromEnum x, fromEnum y ..]
</pre>

<p><li> [Apr 2001] <strong>Page 101, Appendix A, <tt>instance Monad IO</tt>.</strong>
Replace the definition of <tt>fail</tt> in <tt>instance Monad IO</tt> by
<pre>
    fail s = ioError (userError s)
</pre>

<p><li><strong>Page 102, Appendix A, comments immediately before 
<tt>instance Enum Float</tt>.</strong>
Replace "<tt>1.0</tt>" by "<tt>0.95</tt>".

<p> <li> [Apr 2001] <strong>Page 105, Appendix A.1, line 11.</strong>
In the module header for <tt>PreludeList</tt> replace "<tt>Sum</tt>" by "<tt>sum</tt>".

<p><li><strong>Page 105, Appendix A.1 (PreludeList), line 19.</strong>
Correct the type of <tt>map</tt> to
<pre>
  map :: (a -> b) -> [a] -> [b]
</pre>

<p><li><strong>Page 106, definition of <tt>(!!)</tt>.</strong>
Replace the definition of <tt>(!!)</tt> with the following:
<pre>
    -- List index (subscript) operator, 0-origin
    (!!)                :: [a] -> Int -> a
    xs     !! n | n < 0 =  error "Prelude.!!: negative index"
    []     !! _         =  error "Prelude.!!: index too large"
    (x:_)  !! 0         =  x
    (_:xs) !! n         =  xs !! (n-1)
</pre>
(The original version had the property that <tt>([] !! -100)</tt>
reported "index too large".)

<p><li> [Apr 2001] <strong>Page 107, definition of <tt>scanl1</tt> and <tt>scanr1</tt>.</strong>
Replace the definitions of <tt>scanl1</tt> and <tt>scanr1</tt> with these:
<pre>
scanl            :: (a -> b -> a) -> a -> [b] -> [a]
scanl f q xs     =  q : (case xs of
                            []   -> []
                            x:xs -> scanl f (f q x) xs)

scanl1           :: (a -> a -> a) -> [a] -> [a]
scanl1 f (x:xs)  =  scanl f x xs
scanl1 _ []      =  []

scanr1          :: (a -> a -> a) -> [a] -> [a]
scanr1 f []     =  []
scanr1 f [x]    =  [x]
scanr1 f (x:xs) =  f x q : qs
                   where qs@(q:_) = scanr1 f xs 
</pre>
The effect is to make both functions defined on the empty list.


<p><li> [Apr 2001] <strong>Page 108, definition of <tt>take</tt>, <tt>drop</tt>, and <tt>splitAt</tt>.</strong>
Replace the definitions of <tt>take</tt>, <tt>drop</tt>, and <tt>splitAt</tt> with these:
<pre>
    take                   :: Int -> [a] -> [a]
    take n _      | n <= 0 =  []
    take _ []              =  []
    take n (x:xs)          =  x : take (n-1) xs
    
    drop                   :: Int -> [a] -> [a]
    drop n xs     | n <= 0 =  xs
    drop _ []              =  []
    drop n (_:xs)          =  drop (n-1) xs

    splitAt                  :: Int -> [a] -> ([a],[a])
    splitAt n xs             =  (take n xs, drop n xs)
</pre>
The effect is that all three functions are defined on negative arguments.  This
is a semantic change.

<p><li> [May 2001]  <strong>Page 115, instances <tt>Show Int</tt> and <tt>Read Int</tt></strong>. 
Replace the instances for <tt>Show Int</tt> and <tt>Read Int</tt> with
<pre>
    instance  Show Int  where
	showsPrec           = showsPrec . toInteger
	    -- Converting to Integer avoids
	    -- possible difficulty with minInt
    
    instance  Read Int  where
      readsPrec p r = [(fromInteger i, t) | (i,t) <- readsPrec p r]
	    -- Reading at the Integer type avoids
	    -- possible difficulty with minInt
</pre>
The previous definitions (which are simply specifications, remember) failed on minInt.

<p><li> [May 2001]  <strong>Page 132, Appendix D, Specification of Derived Instances</strong>. 
In numbered item 3, replace 
``(all constructors must by nullary)'' with 
``(all constructors must be nullary)''.

<p><li>  [Apr 2001] <strong>Page 141, Bibliograpy</strong>. 
Citation [4] should read "JR Hindley".

<p><li> <strong>Page 141, Bibliograpy</strong>. 
The library report citation [8] is out of date.  It should read:
"Simon Peyton Jones and John Hughes (editors), Standard Libraries for the
Haskell 98 Programming Language, 1 February 1999".

<p><li><strong>Page 147, Index</strong>.  Remove the entry for "monad comprehension".

<p><li> [Apr 2001] <strong>Index of the Haskell 98 Prelude (HTML version only)</strong>
<ul>
<li> Remove <tt>Eval</tt> as a superclass of <tt>Num</tt>
<li> Correct type of <tt>seq</tt> to <tt>seq :: a -> b -> b</tt>.
</ul>
</ul>

<hr>
<h1>Errata in the 
<a href="http://haskell.cs.yale.edu/definition/">Haskell 98 Library Report</a></h1>

<ul>
<p><li> <strong>Title page</strong>.  Add the paragraph:
<p>
"Copyright (c) Simon Peyton Jones and John Hughes.
<p>
The authors intend this Report to belong to the entire Haskell 
community, and so we grant permission to copy and
distribute it for any purpose, provided that it is
reproduced in its entireity, including this Notice.  Modified
versions of this Report may also be copied and distributed for any purpose,
provided that the modified version is clearly presented as such,
and that it does not claim to be a definition of the Haskell 98 libraries."

<p><li>  [Apr 2001] <strong>Page 5, Section 2.1, Library <tt>Ratio</tt></strong>.
Replace the definition of <tt>recip</tt> on line 3 by the following
<pre>
    recip (x:%y)        =  y % x
</pre>
The effect of this change is to use the "smart constructor", <tt>%</tt>, instead
doing it by hand.  In particular, an error will be raised if y is zero.

<p><li> <strong>Page 17, Section 5, first text line</strong>.  Replace "continuous" by "contiguous".

<p><li> [May 2001] <strong>Page 17, Section 5, Indexing operations</strong>.  
Add the following equation to the laws listed just before Section 5.1:
<pre>
  map index (range (l,u)) == [0..rangeSize (l,u)]
</pre>
This documents an invariant that was previously only implicit.

<p><li> [May 2001] <strong>Page 17, Section 5, Indexing operations</strong>.
This significant item (a) removes <tt>Ord</tt> from <tt>Ix</tt>'s superclasses, and
(b) make <tt>rangeSize</tt> into a method of <tt>Ix</tt> rather than a free-standing declaration.
Though these changes are 
visible to the programmer, all existing Haskell 98 programs will continue to work.
<ul>
<li>  <strong>Page 17, Section 5, Indexing operations, boxed text</strong>. Replace the <tt>Ix</tt>
change the class declaration, and the type signature for <tt>rangeSize</tt> with:
<pre>
  class Ix a where
    range     :: (a,a) -> [a]
    index     :: (a,a) -> a -> Int
    inRange   :: (a,a) -> a -> Bool
    rangeSize :: (a,a) -> Int
</pre>
<li> <strong>Section 5.2, pages 19, line 3</strong>. Replace the <tt>Ix</tt>
class declaration, and the <tt>rangeSize</tt> declaration, with:
<pre>
  class Ix a where
    range     :: (a,a) -> [a]
    index     :: (a,a) -> a -> Int
    inRange   :: (a,a) -> a -> Bool
    rangeSize :: (a,a) -> Int

    rangeSize b@(l,h) | null (range b) = 0
                      | otherwise      = index b h + 1 
	-- NB: replacing "null (range b)" by  "not (l <= h)"
	-- fails if the bounds are tuples.  For example,
	-- 	(1,2) <= (2,1)
	-- but the range is nevertheless empty
	--	range ((1,2),(2,1)) = []
</pre>
(Note: the comment has changed too; it was misleading before.)
</ul>

<p><li> [May 2001] <strong>Page 24, Section 6.6</strong>.
Add <tt>Eq a</tt> to the context for <tt>instance Eq (Array a b)</tt>, thus:
<pre>
    instance  (Ix a, Eq a, Eq b)  => Eq (Array a b)  ...
</pre>
Similarly, add <tt>Ord a</tt> to the context for <tt>instance Ord (Array a b)</tt>, thus:
<pre>
    instance  (Ix a, Ord a, Ord b) => Ord (Array a b) ...
</pre>
(Both consequences of removing <tt>Ord</tt> as a superclass of <tt>Ix</tt>.)

<p><li> <strong>Page 22, Section 6.3; and Page 23, Fig 3</strong>:
Replace "<tt>map</tt>" by "<tt>fmap</tt>" (two occurrences in 6.3, one in Fig 3).

<p><li> [May 2001] <strong>Page 23, Figure 3</strong>.
In the definition of <tt>diag</tt>, delete the guard ``<tt>| l==l' &amp;&amp; u==u'</tt>''.
(The original intent was presumably to check for a square array, but
 simply makes the definition recursive and hence divergent.)

<p><li> <strong>Page 29, Section 7.2</strong>.  Add a new bullet for <tt>nub</tt>.
Add an index entry for <tt>nub</tt>.

<p><li> <strong>Page 29, Section 7.2, second bullet</strong>.  
Introduce a new bullet just before "<tt>union</tt> is list union".

<p><li> [May 2001] <strong>Page 30, Section 7.4, unfoldr</strong>.
Replace the first line-and-a-half paragraph with:
<p>
"The <tt>unfoldr</tt> function is a `dual' to <tt>foldr</tt>: while <tt>foldr</tt> reduces a list
to a summary value, <tt>unfoldr</tt> builds a list from a seed value.  For 
example:
<pre>
  iterate f == unfoldr (\x -> Just (x, f x))
</pre>
In some cases, <tt>unfoldr</tt> can undo a <tt>foldr</tt> operation:"
<p>
(Followed by the existing displayed equation.)


<p><li> [May 2001] <strong>Page 32, Section 7.8, Library List</strong>.
<ul> <li> Add <tt>deleteFirstsBy</tt> to the export list.  (It has always
 been in the library, but the report failed to export it!)
<li> Generalise the type signatures of <tt>deleteBy</tt> and <tt>deleteFirstsBy</tt> to:
<pre>
   deleteBy                :: (x -> a -> Bool) -> x -> [a] -> [a]
   deleteFirstsBy          :: (x -> a -> Bool) -> [a] -> [x] -> [a]
</pre>
The definitions have these more general types, and they are occasionally useful.
</ul>

<p><li> [Apr 2001] <strong>Page 34, Section 7.8, Library List</strong>.
Replace the definition of <tt>partition</tt> by
<pre>
   partition               :: (a -> Bool) -> [a] -> ([a],[a])
   partition p xs          =  (filter p xs, filter (not . p) xs)
</pre>
This simply makes it agree with the definition on page 30 (Section 7.3).

<p><li> [Apr 2001] <strong>Page 35, Section 7.8</strong>.
Replace the definitions of <tt>maximumBy</tt> and <tt>minimumBy</tt> by the following
<pre>
    maximumBy               :: (a -> a -> Ordering) -> [a] -> a
    maximumBy cmp []        =  error "List.maximumBy: empty list"
    maximumBy cmp xs        =  foldl1 max xs
			    where
			       max x y = case cmp x y of
					    GT -> x
					    _  -> y
    
    minimumBy               :: (a -> a -> Ordering) -> [a] -> a
    minimumBy cmp []        =  error "List.minimumBy: empty list"
    minimumBy cmp xs        =  foldl1 min xs
			    where
			       min x y = case cmp x y of
					    GT -> y
					    _  -> x
</pre>
<strong>NOTE:</strong> this is a semantic change, but it makes the definitions
consistent with the other "By" functions, and with the signatures given on page 28.

<p><li><strong>Page 54, Section 11</strong>.
The signature for <tt>try</tt> should be
<pre>
  try :: IO a -> IO (Either IOError a)
</pre>

<p><li> [May 2001] <strong>Page 57, Section 11.2.1 Semi-closed handles</strong>.
Replace the sentence "Once a semi-closed handle becomes closed..." with
"Once a semi-closed handle becomes closed, the contents of the
associated list becomes fixed.  The contents of this final list is
only partially specified: it will contain at least all the items of
the stream that were evalutated prior to the handle becoming closed."
<p>
This change attempts to clarify the (murky) meaning of <tt>hGetContents</tt> followed by
<tt>hClose</tt>.

<p><li> [Apr 2001] <strong>Page 56-58, Section 11.2, Files and Handles</strong>.
Add a section 11.2.3 to clarify the file-locking issue.  It says:
<p>
"Implementations should enforce as far as possible, locally to the
Haskell process, multiple-reader single-writer locking on files.
That is, there may either be many handles on the same file which manage
input, or just one handle on the file which manages output.  If any
open or semi-closed handle is managing a file for output, no new
handle can be allocated for that file.  If any open or semi-closed
handle is managing a file for input, new handles can only be allocated
if they do not manage output.  Whether two files are the same is
implementation-dependent, but they should normally be the same if they
have the same absolute path name and neither has been renamed, for
example.

Warning: the <tt>readFile</tt> operation (Section 7.1 of the Haskell Language Report)
holds a semi-closed handle on the file until the entire contents of the file have been
consumed.  It follows that an attempt to write to a file (using <tt>writeFile</tt>, for example)
that was earlier opened by <tt>readFile</tt> will usually result in 
failure with <tt>isAlreadyInUseError</tt>."

<p><li> [May 2001] <strong>Page 59, Section 11.4.2</strong>.
Before "The buffer is emptied as soon as it has been written out." add: 
"An implementation is free to flush the buffer more frequently, but not 
less frequently, than
specified above."  (Clarification only.)

<p><li> [May 2001] <strong>Page 59, Section 11.4.2</strong>.
In the second no-buffering bullet (sixth bullet in the sub-section) add the
sentence: "The <tt>hLookAhead</tt> operation implies that
even a no-buffered handle may require a one-character buffer. "  (Clarification only.)

<p><li><strong>Page 62, Section 11.7.2</strong>.
<ul>
<li>Add a new section heading "<strong>11.7.3 Reading the entire input</strong>"
just before the paragraph about <tt>hGetContents</tt>.  
<li>
Add a new section heading "<strong>11.7.4 Text output</strong>" before the
paragraph about <tt>hPutChar</tt>.
</ul>
<p><li><strong>Page 63, definition of <tt>main</tt> in Section 11.8.1</strong>.
Replace the definition of "<tt>readNum</tt>" with
<pre>
  where readNum :: IO Integer
	-- Need a type signature for readLn to avoid ambiguity
	readNum = readLn
</pre>
(This change merely advertises the generally useful function <tt>readLn</tt>.)


<p><li><strong>Page 64, Section 12, Directory functions.</strong>
(More an editor's blunder than a typo.)
<ul>
<li>
Replace the abstract definition of <tt>Permissions</tt>, and the four instances
of <tt>Permissions</tt> with
<pre>
  data Permissions 
    = Permissions {
        readable, writable, executable, searchable :: Bool
      }
      deriving ( Eq, Ord, Read, Show )
</pre>
<li> Remove <tt>readable, writable, executable, searchable</tt> both from
the module header, and from the module body.
<li> Change <tt>Permissions</tt> to <tt>Permissions(readable, writable, executable, searchable)</tt>
in the module header.
</ul>

<p><li> [Apr 2001] <strong>Page 78, Section 16, The <tt>CPUTime</tt> library</strong>.
Add <tt>cpuTimePrecision</tt> to the export list.

<p><li>[Apr 2001] <strong>Page 81, Section 17.1, The <tt>RandomGen</tt> class</strong>.
This sigificant semantic change adds a method <tt>genRange</tt> to the <tt>RandomGen</tt>
class.  (Extensive discussion on the Haskell mailing list made it clear that this change
is essential to make the RandomGen class useful.)  The following summarises the changes
but not in the detailed line-by-line form used for the rest of the errata.
<ul>
<li> Add a method <tt>genRange :: g -> (Int,Int)</tt> to class <tt>RandomGen</tt>.
<li> Give it the default method <tt>genRange g = (minBound,maxBound)</tt>
<li> Add a specification of <tt>genRange</tt>
<li> Change the header on page 80 to match.
</ul>

<p><li>[Apr 2001] <strong>Page 81, Section 17.1, The <tt>RandomGen</tt> class</strong>.
Specify more precisely that <tt>split</tt> must deliver <strong>independent</strong> generators.

<p><li><strong>Page 81, Section 17.1, The <tt>RandomGen</tt> class</strong>.
Bottom line on page 81: replace "<tt>show/Read</tt> instances" with
"<tt>Show/Read</tt> instances" (i.e. capitalise <tt>Show</tt>).

<p><li><strong>Page 83, Section 17.3, The global random number generator</strong>.
In the first paragraph, replace "kernal" by "kernel".

</ul>
<hr>
<address>Simon Peyton Jones, simonpj@microsoft.com</address>
</body>
</html>

