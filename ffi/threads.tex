\documentclass{article}

\usepackage{proof}
\usepackage{code}

\sloppy
\setlength{\parskip}{0.5\baselineskip plus 0.2\baselineskip minus 0.1\baselineskip}
\setlength{\parsep}{\parskip}
\setlength{\topsep}{0cm}
\setlength{\parindent}{0cm}
\renewcommand{\textfraction}{0}
\renewcommand{\topfraction}{1}
\renewcommand{\floatpagefraction}{0.8}
\renewcommand{\dblfloatpagefraction}{0.8}


\newcommand{\NS}{{\cal N}}
%	NS: set of native threads
\newcommand{\HS}{{\cal H}}
%	HS: set of Haskell threads
\newcommand{\hcall}{H}
\newcommand{\fcall}[2]{F^{#1}~#2}
\newcommand{\ret}[1]{R~#1}


\begin{document}


\title{A semantics for foreign threads}

\author{Simon Peyton Jones \and Simon Marlow}


\makeatactive

\section{Introduction}

Threads created using OS primitives (for example pthreads on POSIX systems) can
have thread-local state. Several libraries make use of this thread-local state.
Most Haskell systems use just one OS thread to execute all foreign code.
With GHC's threaded RTS, this is not even necessarily the same OS thread all the
time.
Therefore it is not possible to use foreign libraries that depend on thread-local
state reliably.

The following foreign libraries are known to be affected:
\begin{itemize}
\item OpenGL
\item Carbon and Cocoa (Apple's GUI toolkits)
\end{itemize}

\section{Requirements}

\begin{itemize}
\item It should be possible for Haskell code to arrange that a sequence of
calls to a given library are performed by the same native thread and
that if an external library calls into Haskell, then any outgoing calls
from Haskell are performed by the same native thread.

\item The specification should be implementable in a way that allows a lot
of foreign calls to be made with no additional overhead with respect to
GHC's current ``unsafe'' foreign calls.

\item The good performance of the existing lightweight ``green'' threads in
GHC should not be sacrificed. Performance should still OK when using
the new features with only a few threads (i.e. not more than commonly
used from multithreaded C programs).

\item The specification shouldn't explicitly require lightweight ``green''
threads to exist. The specification should be implementable in a simple
and obvious way in haskell systems that always use a 1:1 correspondence
between Haskell threads and OS threads.

\item The specification shouldn't specify which particular OS thread
should be used to execute Haskell code. It should be possible to
implement it with e.g. a Haskell interpreter running in one OS thread
that just uses other OS threads for foreign calls.

\item There should be no unexpected blocking. Especially, threadsafe calls
should never cause other threads to block.
\end{itemize}


\section{State}

The state of the system is represented by a pair
$$\NS ; \HS$$
where 
\begin{itemize}
\item $\NS = \{t_1, \ldots ,t_n\}$ is a set of \emph{native threads}.
A native thread is directly supported by the underlying operating
system, and may have some thread-local state. It may therefore
be important which native thread executes foreign
(non-Haskell) code.

\item $\HS = \{h_1, \ldots ,h_n\}$ is a set of \emph{Haskell threads}.
Haskell threads are supposed to be extremely lightweight, and
can be created very cheaply. A Haskell thread can only make progress
if a native thread acts as its execution engine.
\end{itemize}

The syntax of a native thread is this:
$$
\begin{array}{lrcll}
\mbox{Native thread} &  t & ::= & N[S] \\
\\
\mbox{Native thread stack} &  S & ::= & \epsilon & \mbox{Empty}\\
	& & | & \hcall : S  & \mbox{Executing Haskel} \\
	& & | & \fcall{si}{h} : S & \mbox{Executing foreign code}\\
	& & | & \bullet & \mbox{Unknown}\\
\\
\mbox{Safety indicator} &  si & ::= & u & \mbox{Unsafe} \\
	& & | & s & \mbox{Safe} \\
	& & | & t & \mbox{Thread-safe} \\
\end{array}
$$
A native thread of form $N[S]$ has thread-id $N$, while $S$ is
an abstraction of its call stack.  If $\hcall$ is on top of the stack,
the thread is willing to execute a Haskell thread.
\emph{(What about referring to the $\hcall$ state as
``inside the Haskell runtime system''? It includes things like GC and other
``administrative tasks''. A native thread might be in the $\hcall$ state 
without ever really executing Haskell code.)}
If $\fcall{si}{h}$ is
on top of the stack, the thread is in the process of dealing with a call
to a foreign function, which will return its result to the Haskell thread
$h$.  The safety-indicator $si$ is from the FFI spec.

The syntax of a Haskell thread is this:
$$
\begin{array}{lrcll}
\mbox{Haskell thread} &  h & ::= & (a)_{bt} \\
\\
\mbox{Haskell action} &  a & ::= & p ~@>>@~ a  & \mbox{Sequence} \\
	& & | & \ret{N}  & \mbox{Return to native thread $N$} \\
\\
\mbox{Primitive action} &  p & ::= & \tau & \mbox{Internal action} \\
	& & | & \fcall{si}{f} & \mbox{Foreign call} \\
\\
\mbox{Bound thread id} & bt & ::= & \epsilon & \mbox{Not bound} \\
	& & | & N & \mbox{Bound to native thread N}
\end{array}
$$
A Haskell thread $h$ of form $(a)_{bt}$ has action $a$.  The indicator
$bt$ tells whether the Haskell thread is \emph{bound to} a native
thread.  If $bt$ is $\epsilon$, the Haskell thread is not bound to a
native thread; if $bt$ is $N$, the Haskell thread is bound to native
thread $N$.  Specifing exactly what it means for a Haskell thread to
be bound to a native thread is the main purpose of this document.

An action $a$ is a sequence of primitive actions, finishing with a 
return of some kind.  A primitive action is either some internal Haskell
thing (such as performing a bit of evaluation, or operating on an @MVar@),
or else it is a call to a foreign function $f$.

We do not model the data passed to, or returned from, a foreign call, nor
any details of what ``internal Haskell'' operations are.  

\section{Evolution}

We describe how the system evolves in a very standard way, using 
transition rules, of form
$$
\NS ; \HS ~\Rightarrow~ \NS' ; \HS'
$$
The structural rules are these:
$$
\begin{array}{c}
\infer{\NS \cup \{t\} ; \HS ~\Rightarrow~ \NS'  \cup \{t\}; \HS'}
	{\NS ; \HS ~\Rightarrow~ \NS' ; \HS'}
\qquad
\infer{\NS ; \HS  \cup \{h\} ~\Rightarrow~ \NS'; \HS'   \cup \{h\}}
	{\NS ; \HS ~\Rightarrow~ \NS' ; \HS'}
\end{array}
$$
These standard rules allow us to write the interesting transitions with less clutter.
$$
\begin{array}{rcll}
N[\hcall:S]; (\tau~@>>@~a)_{bt} 
	& \Rightarrow 
	& N[\hcall:S]; (a)_{bt} & (INT) \\
\\
N[\hcall]; (\fcall{si}{f}~@>>@~a)_{\epsilon} 
	& \Rightarrow 
	& N[\fcall{si}{a_\epsilon}:\hcall];  & (FCALL1) \\
\\
N[\hcall:S]; (\fcall{si}{f}@>>@~a)_N 
	& \Rightarrow 
	& N[\fcall{si}{a_N}:\hcall:S];  & (FCALL2) \\
\\
N[\fcall{si}{a_{bt}}:S];  
	& \Rightarrow 
	& N[S]; a_{bt} & (FRET) \\
\\
N[\bullet];
	& \Rightarrow 
	& N[\hcall:\bullet];  (f ~@>>@~ \ret{N})_{bt} & (HCALL1) \\
	& \multicolumn{2}{l}{\mbox{where}~ bt \begin{array}[t]{ll}
		= \epsilon & \mbox{if $f$ is a non-bound foreign export} \\
		= N & \mbox{if $f$ is a bound foreign export}
	   \end{array}} \\
\\
N[\fcall{si}{a_{bt}} : S]; 
	& \Rightarrow 
	& N[\hcall : \fcall{si}{a_{bt}} : S]; ~ (f ~@>>@~ \ret{N})_{bt} & (HCALL2) \\
	& \multicolumn{2}{l}{\mbox{where}~si \in \{s,t\}} \\
	& \multicolumn{2}{l}{\mbox{and}~ bt \begin{array}[t]{ll}
		= \epsilon & \mbox{if $f$ is a non-bound foreign export} \\

		= N & \mbox{if $f$ is a bound foreign export}
	   \end{array}} \\
\\
N[\hcall : S]; \ret{N} 
	& \Rightarrow 
	& N[S]; & (HRET) \\
\\
(nothing)
	& \Rightarrow 
	& N[\hcall]; & (WKR) \\
	& \multicolumn{2}{l}{\mbox{where $N$ is fresh}} \\
\\
(nothing)
	& \Rightarrow 
	& N[\bullet]; & (EXT) \\
	& \multicolumn{2}{l}{\mbox{where $N$ is fresh}} \\
\end{array}
$$
Here is what the rules mean:
\begin{itemize}
\item (INT) says that an internal action of a Haskell thread 
can be executed by any native thread that 
is in the Haskell state; that is, has $H$ on top of its stack.  This is true
even if the native thread has called a bound foreign export, and that 
Haskell function is still running.

\item On the other hand, (FCALL1) says that only a vanilla worker thread $N[H]$ (i.e. with
nothing on its stack except $H$) can execute an unbound foreign call.  Similarly (FCALL2) says
that only native thread $N$ can execute a foreign call from a Haskell thread bound to $N$.
(This is under the proposal that foriegn imports are not labelled bound/unbound.)

\item In either (FCALL) case, the Haskell thread is removed from the pool, and captured in the
native thread's stack.  The rule (FRET) reinstates the Haskell thread (bound or otherwise)
when the native thread decides to return from the call.

\item Rules (HCALL1) and (HCALL2) deal with foreign code calling Haskell. (HCALL1) 
starts with a native thread that comes ``out of the blue'' with an unknown stack $\bullet$.
It just puts a new Haskell thread into the pool, bound or otherwise depending on 
whether the foreign export being called is labelled as bound.

(HCALL2) is similar, except that we aren't allowed to make such a call if
the native thread is in the middle of an unsafe foreign call.  The difference
between (HCALL1) and (HCALL2) looks very unsavoury.

\item (HRET) deals with returning from a completed Haskell thread to the appropriate
calling native thread.  Notice that even an unbound Haskell thread must return its result
to the right calling native thread, hence the ``return action'' $\ret{t}$ tacked onto
the end of the Haskell thread.

\item (WKR) and (EXT) allow new native threads to enter the system.

\end{itemize}


\end{document}
