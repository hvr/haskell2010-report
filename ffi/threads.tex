\documentclass{article}

\usepackage{proof}
\usepackage{code}

\sloppy
\setlength{\parskip}{0.5\baselineskip plus 0.2\baselineskip minus 0.1\baselineskip}
\setlength{\parsep}{\parskip}
\setlength{\topsep}{0cm}
\setlength{\parindent}{0cm}
\renewcommand{\textfraction}{0}
\renewcommand{\topfraction}{1}
\renewcommand{\floatpagefraction}{0.8}
\renewcommand{\dblfloatpagefraction}{0.8}


\newcommand{\NS}{{\cal N}}
%	NS: set of native threads
\newcommand{\HS}{{\cal H}}
%	HS: set of Haskell threads
\newcommand{\hcall}{HCALL}
\newcommand{\fcall}[2]{FCALL^{#1}~#2}
\newcommand{\ret}[1]{RET~#1}


\begin{document}


\title{A semantics for foreign threads}

\author{Simon Peyton Jones \and Simon Marlow}


\makeatactive

\section{Introduction}

\emph{Insert the foreign-thread justification here.}

Simon and I are confused by what it means. This is our attempt to specify it precisely.

\section{State}

The state of the system is represented by a pair
$$\NS ; \HS$$
where 
\begin{itemize}
\item $\NS = \{t_1, \ldots ,t_n\}$ is a set of \emph{native threads}.
A native thread is directly supported by the underlying operating
system, and may have some thread-local state. It may therefore
be important which native thread executes foreign
(non-Haskell) code.

\item $\HS = \{h_1, \ldots ,h_n\}$ is a set of \emph{Haskell threads}.
Haskell threads are supposed to be extremely lightweight, and
can be created very cheaply. A Haskell thread can only make progress
if a native thread acts as its execution engine.
\end{itemize}

The syntax of a native thread is this:
$$
\begin{array}{lrcll}
\mbox{Native thread} &  t & ::= & N[stk] \\
\\
\mbox{Native thread stack} &  stk & ::= & \epsilon & \mbox{Empty}\\
	& & | & \hcall : stk  & \mbox{Executing Haskel} \\
	& & | & \fcall{si}{h} : stk & \mbox{Executing foreign code}\\
\\
\mbox{Safety indicator} &  si & ::= & u & \mbox{Unsafe} \\
	& & | & s & \mbox{Safe} \\
	& & | & t & \mbox{Thread-safe} \\
\end{array}
$$
A native thread of form $N[stk]$ has thread-id $N$, while $stk$ is
an abstraction of its call stack.  If $\hcall$ is on top of the stack,
the thread is willing to execute a Haskell thread.  If $\fcall{si}{h}$ is
on top of the stack, the thread is in the process of dealing with a call
to a foreign function, which will return its result to the Haskell thread
$h$.  The safety-indicator $si$ is from teh FFI spec.

The syntax of a Haskell thread is this:
$$
\begin{array}{lrcl}
\mbox{Haskell thread} &  h & ::= & (a)_{bt} \\
\\
\mbox{Haskell action} &  a & ::= & pa ~@>>@~ a \\
	& & | & @ret@ \\
\\
\mbox{Primitive action} &  a & ::= & \tau \\
	& & | & \fcall{si}{f} \\
\\
\mbox{Bound task id} & bt & ::= & \epsilon \\
	& & | & N
\end{array}
$$
A Haskell thread $h$ of form $(a)_{bt}$ has action $a$.  The indicator
$bt$ tells whether the Haskell thread is \emph{bound to} a native
thread.  If $bt$ is $\epsilon$, the Haskell thread is not bound to a
native thread; if $bt$ is $N$, the Haskell thread is bound to native
thread $N$.  Specifing exactly what it means for a Haskell thread to
be bound to a native thread is the main purpose of this document.

An action $a$ is a sequence of primitive actions, finishing with a 
return of some kind.  A primitive action is either some internal Haskell
thing (such as performing a bit of evaluation, or operating on an @MVar@),
or else it is a call to a foreign function $f$.

We do not model the data passed to, or returned from, a foreign call, nor
any details of what ``internal Haskell'' operations are.  

\section{Evolution}

We describe how the system evolves in a very standard way, using 
transition rules, of form
$$
\NS ; \HS ~\Rightarrow~ \NS' ; \HS'
$$
The structural rules are these:
$$
\begin{array}{c}
\infer{\NS \cup \{t\} ; \HS ~\Rightarrow~ \NS'  \cup \{t\}; \HS'}
	{\NS ; \HS ~\Rightarrow~ \NS' ; \HS'}
\qquad
\infer{\NS ; \HS  \cup \{h\} ~\Rightarrow~ \NS'; \HS'   \cup \{h\}}
	{\NS ; \HS ~\Rightarrow~ \NS' ; \HS'}
\end{array}
$$
These standard rules allow us to write the interesting transitions with less cluter.
$$
\begin{array}{rcll}
T[\hcall:stk]; (\tau~@>>@~a)_{bt} 
	& \Rightarrow 
	& T[\hcall:stk]; (a)_{bt} & (INT) \\
\\
T[\hcall]; (\fcall{si}{f}~@>>@~a)_{\epsilon} 
	& \Rightarrow 
	& T[\fcall{si}{a_\epsilon},\hcall];  & (FCALL1) \\

\\
T[\hcall:stk]; (@fcall@~f~@>>@~a)_T 
	& \Rightarrow 
	& T[\fcall{si}{a_T}:stk];  & (FCALL2) \\
\\
T[\fcall{si}{a_{bt}}:stk];  
	& \Rightarrow 
	& T[stk]; a_{bt} & (FRET) \\
\\
% empty %
	& \Rightarrow 
	& \nu(~T[\hcall];  (f ~@>>@~ \ret{T})_{bt}) & (HCALL1) \\
	& \multicolumn{2}{l}{\mbox{where} bt \begin{array}[t]{ll}
		\epsilon & \mbox{if $f$ is a non-bound foreign export} \\
		T & \mbox{if $f$ is a bound foreign export}
	   \end{array}} \\
\\
T[\fcall{si}{a_{bt}} : stk]; 
	& \Rightarrow 
	& T[\hcall : \fcall{si}{a_{bt}} : stk]; ~ (f ~@>>@~ \ret{T})_{bt} & (HCALL2) \\
	& \multicolumn{2}{l}{\mbox{where}~si \in \{s,t\}} \\
	& \multicolumn{2}{l}{\mbox{and} bt \begin{array}[t]{ll}
		\epsilon & \mbox{if $f$ is a non-bound foreign export} \\

		T & \mbox{if $f$ is a bound foreign export}
	   \end{array}} \\
\\
T[\hcall : stk]; \ret{T} 
	& \Rightarrow 
	& T[stk]; & (HRET) \\
\\
% empay $
	& \Rightarrow 
	& \nu{ T[\hcall]; ) & (SPAWN) \\
\end{array}
$$
Here is what the rules mean:
\begin{itemize}
\item 
\end{document}
