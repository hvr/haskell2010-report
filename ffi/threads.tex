\documentclass{article}

\usepackage{proof}
\usepackage{code}

\sloppy
\setlength{\parskip}{0.5\baselineskip plus 0.2\baselineskip minus 0.1\baselineskip}
\setlength{\parsep}{\parskip}
\setlength{\topsep}{0cm}
\setlength{\parindent}{0cm}
\renewcommand{\textfraction}{0}
\renewcommand{\topfraction}{1}
\renewcommand{\floatpagefraction}{0.8}
\renewcommand{\dblfloatpagefraction}{0.8}


\newcommand{\NS}{{\cal N}}
%	NS: set of native threads
\newcommand{\HS}{{\cal H}}
%	HS: set of Haskell threads
\newcommand{\hcall}{H}
\newcommand{\fcall}[2]{F^{#1}~#2}
\newcommand{\ret}[1]{R~#1}


\begin{document}


\title{A semantics for foreign threads}

\author{The Haskell FFI team}
\maketitle

\makeatactive

\section{Introduction}

Threads created using OS primitives (for example pthreads on POSIX systems) can
have thread-local state. Several libraries make use of this thread-local state.
Most Haskell systems use just one OS thread to execute all foreign code.
With GHC's threaded RTS, this is not even necessarily the same OS thread all the
time.
Therefore it is not possible to use foreign libraries that depend on thread-local
state reliably.

The following foreign libraries are known to be affected:
\begin{itemize}
\item OpenGL
\item Carbon and Cocoa (Apple's GUI toolkits)
\end{itemize}

\section{Requirements}

\begin{itemize}
\item It should be possible for Haskell code to arrange that a sequence of
calls to a given library are performed by the same native thread and
that if an external library calls into Haskell, then any outgoing calls
from Haskell are performed by the same native thread.

\item The specification should be implementable in a way that allows a lot
of foreign calls to be made with no additional overhead with respect to
GHC's current ``unsafe'' foreign calls.

\item The good performance of the existing lightweight ``green'' threads in
GHC should not be sacrificed. Performance should still OK when using
the new features with only a few threads (i.e. not more than commonly
used from multithreaded C programs).

\item The specification shouldn't explicitly require lightweight ``green''
threads to exist. The specification should be implementable in a simple
and obvious way in haskell systems that always use a 1:1 correspondence
between Haskell threads and OS threads.

\item The specification shouldn't specify which particular OS thread
should be used to execute Haskell code. It should be possible to
implement it with e.g. a Haskell interpreter running in one OS thread
that just uses other OS threads for foreign calls.

\item There should be no unexpected blocking. Especially, threadsafe calls
should never cause other threads to block.
\end{itemize}


\section{Proposed design}

The key extension is the ability to create a ``bound'' foreign export,
that can be called from a foreign language.
The intuitive idea is that ``@bound@'' means that the native OS thread that makes
the call into Haskell is also guaranteed to run any @foreign@ calls that the
Haskell thread makes.  

\subsection{Extension to the FFI Syntax}

A bound foreign export is declared by adding the specialid \texttt{bound}
after the calling convention (before the exported entity string).

The bound attribute can also apply to thunks created by foreign imported
"wrapper" functions. These stub factories are the only situation where the
\texttt{bound} attribute applies. 

Example:
\begin{quote}
\begin{verbatim}
foreign export ccall bound "CFoo" haskellFoo
    :: IO ()
foreign import ccall bound "wrapper" wrapHaskellFoo
    :: IO () -> IO (FunPtr (IO ())) 
\end{verbatim}
\end{quote}

The \texttt{bound} attribute should only be valid for exported entities
that are in the IO monad.


\subsection{Library Addition}

A function named \texttt{forkBoundThread} should be added to the library
(somewhere in \texttt{Foreign} or \texttt{Concurrent}).
A possible implementation for POSIX systems is given below.

\begin{quote}
\begin{verbatim}
forkBoundThread :: IO () -> IO ()

-- pthread_create(thread, attr, start_routine, arg)
foreign import ccall pthread_create
    :: Ptr (Ptr ())
    -> Ptr ()
    -> FunPtr (Ptr () -> IO (Ptr ()))
    -> Ptr ()
    -> IO CInt

foreign export ccall bound "wrapper" wrapHaskell
    :: (Ptr () -> IO (Ptr ()))
    -> IO (FunPtr (Ptr () -> IO (Ptr ())))
    
forkBoundThread action =
    wrapHaskell (\ptr -> do
            freeHaskellFunPtr thunk
            action
            return nullPtr
        )
    >>= \thunk -> alloca
    >>= \thread -> pthread_create thread nullPtr thunk nullPtr
    >> return ()

\end{verbatim}
\end{quote}

\section{Operational semantics}

While the intuition is clear, it is quite difficult to say \emph{precisely} what a ``@bound@'' export means.
The purpose of this section is to give a precise description, using a simple operational semantics.


\subsection{State}

The state of the system is represented by a pair
$$\NS ; \HS$$
where 
\begin{itemize}
\item $\NS = \{t_1, \ldots ,t_n\}$ is a set of \emph{native threads}.
A native thread is directly supported by the underlying operating
system, and may have some thread-local state. It may therefore
be important which native thread executes foreign
(non-Haskell) code.

\item $\HS = \{h_1, \ldots ,h_n\}$ is a set of \emph{Haskell threads}.
Haskell threads are supposed to be extremely lightweight, and
can be created very cheaply. A Haskell thread can only make progress
if a native thread acts as its execution engine.
\end{itemize}

The syntax of a native thread is this:
$$
\begin{array}{lrcll}
\mbox{Native thread} &  t & ::= & N[S] \\
\\
\mbox{Native thread stack} &  S & ::= & \epsilon & \mbox{Empty}\\
	& & | & \hcall : S  & \mbox{Executing Haskel} \\
	& & | & \fcall{si}{h} : S & \mbox{Executing foreign code}\\
	& & | & \bullet & \mbox{Unknown}\\
\\
\mbox{Safety indicator} &  si & ::= & u & \mbox{Unsafe} \\
	& & | & s & \mbox{Safe} \\
	& & | & t & \mbox{Thread-safe} \\
\end{array}
$$
A native thread of form $N[S]$ has thread-id $N$, while $S$ is
an abstraction of its call stack.  If $\hcall$ is on top of the stack,
the thread is willing to execute a Haskell thread.
\emph{(What about referring to the $\hcall$ state as
``inside the Haskell runtime system''? It includes things like GC and other
``administrative tasks''. A native thread might be in the $\hcall$ state 
without ever really executing Haskell code.)}
If $\fcall{si}{h}$ is
on top of the stack, the thread is in the process of dealing with a call
to a foreign function, which will return its result to the Haskell thread
$h$.  The safety-indicator $si$ is from the FFI spec.

The syntax of a Haskell thread is this:
$$
\begin{array}{lrcll}
\mbox{Haskell thread} &  h & ::= & (a)_{bt} \\
\\
\mbox{Haskell action} &  a & ::= & p ~@>>@~ a  & \mbox{Sequence} \\
	& & | & \ret{N}  & \mbox{Return to native thread $N$} \\
\\
\mbox{Primitive action} &  p & ::= & \tau & \mbox{Internal action} \\
	& & | & \fcall{si}{f} & \mbox{Foreign call} \\
\\
\mbox{Bound thread id} & bt & ::= & \epsilon & \mbox{Not bound} \\
	& & | & N & \mbox{Bound to native thread N}
\end{array}
$$
A Haskell thread $h$ of form $(a)_{bt}$ has action $a$.  The indicator
$bt$ tells whether the Haskell thread is \emph{bound to} a native
thread.  If $bt$ is $\epsilon$, the Haskell thread is not bound to a
native thread; if $bt$ is $N$, the Haskell thread is bound to native
thread $N$.  Specifing exactly what it means for a Haskell thread to
be bound to a native thread is the main purpose of this document.

An action $a$ is a sequence of primitive actions, finishing with a 
return of some kind.  A primitive action is either some internal Haskell
thing (such as performing a bit of evaluation, or operating on an @MVar@),
or else it is a call to a foreign function $f$.

We do not model the data passed to, or returned from, a foreign call, nor
any details of what ``internal Haskell'' operations are.  

\subsection{Evolution}

We describe how the system evolves in a very standard way, using 
transition rules, of form
$$
\NS ; \HS ~\Rightarrow~ \NS' ; \HS'
$$
The structural rules are these:
$$
\begin{array}{c}
\infer{\NS \cup \{t\} ; \HS ~\Rightarrow~ \NS'  \cup \{t\}; \HS'}
	{\NS ; \HS ~\Rightarrow~ \NS' ; \HS'}
\qquad
\infer{\NS ; \HS  \cup \{h\} ~\Rightarrow~ \NS'; \HS'   \cup \{h\}}
	{\NS ; \HS ~\Rightarrow~ \NS' ; \HS'}
\end{array}
$$
These standard rules allow us to write the interesting transitions with less clutter.
$$
\begin{array}{rcll}
N[\hcall:S]; (\tau~@>>@~a)_{bt} 
	& \Rightarrow 
	& N[\hcall:S]; (a)_{bt} & (INT) \\
\\
N[\hcall]; (\fcall{si}{f}~@>>@~a)_{\epsilon} 
	& \Rightarrow 
	& N[\fcall{si}{a_\epsilon}:\hcall];  & (FCALL1) \\
\\
N[\hcall:S]; (\fcall{si}{f}@>>@~a)_N 
	& \Rightarrow 
	& N[\fcall{si}{a_N}:\hcall:S];  & (FCALL2) \\
\\
N[\fcall{si}{a_{bt}}:S];  
	& \Rightarrow 
	& N[S]; a_{bt} & (FRET) \\
\\
N[\bullet];
	& \Rightarrow 
	& N[\hcall:\bullet];  (f ~@>>@~ \ret{N})_{bt} & (HCALL1) \\
	& \multicolumn{2}{l}{\mbox{where}~ bt \begin{array}[t]{ll}
		= \epsilon & \mbox{if $f$ is a non-bound foreign export} \\
		= N & \mbox{if $f$ is a bound foreign export}
	   \end{array}} \\
\\
N[\fcall{si}{a_{bt}} : S]; 
	& \Rightarrow 
	& N[\hcall : \fcall{si}{a_{bt}} : S]; ~ (f ~@>>@~ \ret{N})_{bt} & (HCALL2) \\
	& \multicolumn{2}{l}{\mbox{where}~si \in \{s,t\}} \\
	& \multicolumn{2}{l}{\mbox{and}~ bt \begin{array}[t]{ll}
		= \epsilon & \mbox{if $f$ is a non-bound foreign export} \\

		= N & \mbox{if $f$ is a bound foreign export}
	   \end{array}} \\
\\
N[\hcall : S]; \ret{N} 
	& \Rightarrow 
	& N[S]; & (HRET) \\
\\
(nothing)
	& \Rightarrow 
	& N[\hcall]; & (WKR) \\
	& \multicolumn{2}{l}{\mbox{where $N$ is fresh}} \\
\\
(nothing)
	& \Rightarrow 
	& N[\bullet]; & (EXT) \\
	& \multicolumn{2}{l}{\mbox{where $N$ is fresh}} \\
\end{array}
$$
Here is what the rules mean:
\begin{itemize}
\item (INT) says that an internal action of a Haskell thread 
can be executed by any native thread that 
is in the Haskell state; that is, has $H$ on top of its stack.  This is true
even if the native thread has called a bound foreign export, and that 
Haskell function is still running.

\item On the other hand, (FCALL1) says that only a vanilla worker thread $N[H]$ (i.e. with
nothing on its stack except $H$) can execute an unbound foreign call.  Similarly (FCALL2) says
that only native thread $N$ can execute a foreign call from a Haskell thread bound to $N$.
(This is under the proposal that foreign imports are not labelled bound/unbound.)

\item In either (FCALL) case, the Haskell thread is removed from the pool, and captured in the
native thread's stack.  The rule (FRET) reinstates the Haskell thread (bound or otherwise)
when the native thread decides to return from the call.

\item Rules (HCALL1) and (HCALL2) deal with foreign code calling Haskell. (HCALL1) 
starts with a native thread that comes ``out of the blue'' with an unknown stack $\bullet$.
It just puts a new Haskell thread into the pool, bound or otherwise depending on 
whether the foreign export being called is labelled as bound.

(HCALL2) is similar, except that we aren't allowed to make such a call if
the native thread is in the middle of an unsafe foreign call.  The difference
between (HCALL1) and (HCALL2) looks very unsavoury.

\item (HRET) deals with returning from a completed Haskell thread to the appropriate
calling native thread.  Notice that even an unbound Haskell thread must return its result
to the right calling native thread, hence the ``return action'' $\ret{t}$ tacked onto
the end of the Haskell thread.

\item (WKR) and (EXT) allow new native threads to enter the system.

\end{itemize}

\section{Issues}

\begin{itemize}

\item Somebody suggested labelling foreign imports as bound or unbound,
and allowing the RTS to choose any thread it wants for executing unbound
foreign imports.

However, we need top performance for \emph{all} foreign imports, not just
unbound ones. HOpenGL applications make hundreds and thousands of unsafe calls,
all of which have to be bound to a specific native thread.
Now if bound foreign imports need to be as fast as unbound foreign imports
\footnote{This will be the case in GHC}, we don't need the additional
complexity.

\item The meaning of "\texttt{bound}" in the FFI declarations is probably
rather unobvious to people who haven't been following this discussion. Can
somebody think of something that is more meaningful?

\item Some very broken libraries (Apple's GUI libraries) seem to have
initialization routines (that run prior to main) which initialize thread local
state for the "main thread" (the OS thread that the C language \texttt{main()}
function runs in). Some routines can then only be run in that main thread. Some
way is needed to allow the programmer to specify that the haskell thread that
the \texttt{main} action runs in should be bound to the main OS thread.

\item In which module in the libraries should the \texttt{forkBoundThread}
function go?

\end{itemize}

\end{document}
