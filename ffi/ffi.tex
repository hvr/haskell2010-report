% The Haskell 98 Foreign Function Interface
% [An Addendum to the Definition of Haskell 98]
%
% Editor: Manuel M. T. Chakravarty
%
% Copyright 2001 Manuel M. T. Chakravarty
%
% The authors intend this Report to belong to the entire Haskell community, and
% so we grant permission to copy and distribute it for any purpose, provided
% that it is reproduced in its entirety, including this Notice.  Modified
% versions of this Report may also be copied and distributed for any purpose,
% provided that the modified version is clearly presented as such, and that it
% does not claim to be a definition of the Haskell 98 Foreign Function
% Interface. 
 
\documentclass[a4paper,twosides]{article}

\usepackage{a4wide}
\usepackage{grammar}  % Get it from 
                      %   http://www.cse.unsw.edu.au/~chak/haskell/grammar.sty
\usepackage{version}
\usepackage{url}
\usepackage[fleqn]{amsmath}


% version control
%
\includeversion{DRAFT}
%\excludeversion{DRAFT}

\def\Version{\relax}
\begin{DRAFT}%
{
  \gdef\Version{%
    \\
    \textbf{--- DRAFT ---}\\[1ex]
    \ttfamily\scriptsize
    $\relax$Id: ffi.tex,v 1.13 2001/08/30 16:03:50 chak Exp $\relax$%
    \ignorespaces}
  }
\end{DRAFT}

% setting of code
%
\newcommand{\code}[1]{\texttt{#1}}      % inline code fragment
\makeatletter
\newenvironment{codedesc}{%             % description of code pieces
  \list{}{\labelwidth\z@
    \let\makelabel\codedesclabel}
  }{%
  \endlist
  }
\newcommand*{\codedesclabel}[1]{%
  \hspace{-\leftmargin}
  \parbox[b]{\labelwidth}{\makebox[0pt][l]{\code{#1}}\\}\hfil\relax
  }
\makeatother
\newcommand{\combineitems}{\vspace*{-\itemsep}\vspace*{-\parsep}\vspace*{-1em}}


\begin{document}
\pagestyle{headings}

\title{%
  The Haskell 98 Foreign Function Interface\\
  An Addendum to the Definition of Haskell 98%
  \Version}
\author{
  Manuel M. T. Chakravarty [editor], University of New South Wales\\
  Sigbjorn Finne, Galois Connections\\
  Fergus Henderson, University of Melbourne\\
  Marcin Kowalczyk, Warsaw University\\
  Daan Leijen, University of Utrecht\\
  Simon Marlow, Microsoft Research\\
  Erik Meijer, Microsoft\\
  Sven Panne, BetaResearch\\
  Simon Peyton Jones, Microsoft Research\\
  Alastair Reid, University of Utah\\
  Malcolm Wallace, University of York\\
  Michael Weber, University of Aachen
  }
\date{}
\maketitle


\newpage
\section*{Preface}

\subsection*{Acknowledgements}


\newpage
\section{Introduction}

The definition of Haskell 98~\cite{haskell98}, while being comprehensive with
respect to the functional core language, does lack a range of features of more
operational flavour, such as a foreign language interface, concurrency
support, and fully fledged exception handling.  As these features are of
central importance to many real world applications of the language, there is a
danger that different implementations become de facto incompatible for such
applications due to system-specific extensions of the core language.  The
present FFI specification is aimed at reducing this risk by defining a simple,
yet comprehensive extension to Haskell 98 for the purpose of interfacing to
program components implemented in a language other than Haskell.

The goal behind this foreign function interface (FFI) specification is
twofold: It must be possible (1) to describe in Haskell the interface to
foreign functionality and (2) to use from foreign code Haskell routines.  More
precisely, the aim is to be able to implement programs in a mixture of Haskell
and other languages such that the source code is portable across different
implementations of Haskell and non-Haskell systems as well as architecture
and operating system independent.

Central in the design of this interface, which builds on experiences with a
couple of foreign function interfaces provided by the major Haskell
implementations, has been the goal to be comprehensive while being simple and
minimising the change with respect to Haskell 98; the latter includes
pollution of the name space with new keywords.  Consequently, as much as
possible the FFI functionality is realised in the form of libraries.
Simplicity generally overruled maximal convience for the programmer as a
design goal.  Thus, support for more convenient interface specifications is
the domain of system-independent tools that generate code following the
present specification.

\subsection{Embedding Into Haskell 98}

The present report is to be regarded as an addendum to the Haskell 98
Report~\cite{haskell98}.  As such, syntactic and semantic definitions refer to
names and definitions in the Haskell 98 Report where appropriate without
further explanation.  Care has been taken to invalidate as few as possible
legal Haskell 98 programs in the process of adding FFI support.  In
particular, only a single addition to the set of reserved identifiers, namely
\code{foreign}, has been made.

Moreover, it is expected that the present FFI specification will be considered
for inclusion into future revisions of the Haskell standard.

\subsection{Language-Specific FFI Support}

The core of the present specification is independent of the foreign language.
However, there are two areas where FFI specifications must become language
specific: (1) the specification of external names and (2) the marshalling of
the basic types of a foreign language.  As an example of the former, consider
that in C~\cite{C} a simple identifier is sufficient to identify an object,
while Java~\cite{gosling-etal:Java}, in general, requires a qualified name in
conjunction with argument and result types to resolve possible overloading.
Regarding the second point, note that many languages do not specify the exact
representation of some basic types.  For example the type \code{int} in C may
be 16, 32, or 64 bits wide.  Similarly, the Haskell report guarantees only that
\code{Int} covers at least the range \([-2^{29}, 2^{29} - 1]\).  As a
consequence, to reliably represent values of C's \code{int} in Haskell, we
have to introduce a new type \code{CInt}, which is guaranteed to match the
representation of \code{int}.

The specification of external names, dependent on a calling convention, is
described in Section~\ref{sec:extent}, whereas the marshalling of the basic
types dependent on a foreign language is described in
Section~\ref{sec:marshalling}.

\subsection{Contexts}

For a given Haskell system, we define the \emph{Haskell context} to be the
execution context of the abstract machine on which the Haskell system is
based.  This includes the heap, stacks, and the registers of the abstract
machine and their mapping onto a concrete architecture.  We call any other
execution context an \emph{external context.}  Generally, we cannot assume any
compatibility between the data formats and calling conventions between the
Haskell context and a given external context, except where the Haskell 98
report explicitly prescribes a specific data format.

The principal goal of a foreign function interface is to provide a
programmable interface between the Haskell context and external contexts.  As
a result Haskell threads can access data in external contexts and invoke
functions that are executed in an external context as well as vice versa.  In
the rest of this report, external contexts are usually identified by a calling
convention. 


\newpage
\section{Lexical Structure}

The only addition to the lexical structure of Haskell 98 as defined
in~\cite[Section~2]{haskell98} is a single new reserved identifier and a set
of special identifiers.  The latter have a special meaning only within foreign
declarations, but may be used as ordinary identifiers elsewhere.

The following productions are added:
%
\begin{grammar}
  \grule{reservedid}{%
    foreign}
  \grule{specialid}{%
    dynamic \galt\ export \galt\ safe \galt\ static \galt\
    unsafe}
  \gor{%
    ccall \galt\ stdcall \galt\ cplusplus \galt\ jvm \galt\ dotnet}
  \gor{%
    \gverbal{system-specific calling conventions}}
\end{grammar}


\newpage
\section{Foreign Declarations}

This section describes the extension of Haskell 98 by foreign declarations.
The production for the non-terminal \gnterm{topdecl} extends the corresponding
non-terminal from the Haskell 98 Report.  All other non-terminals introduced
in the following are new.
%
\begin{grammar}
  \grule{topdecl}{%
    foreign \gnterm{fdecl}}
  \grule[define variable]{fdecl}{%
    import \gnterm{callconv} \gopt{\gnterm{safety}} \gnterm{entity}
    \gnterm{var} {::}\ \gnterm{ftype}}
  \gor[expose variable]{%
    export \gnterm{callconv} \gnterm{entity}
    \gnterm{var} {::}\ \gnterm{ftype}}
  \grule[calling convention]{callconv}{%
    ccall \galt\ stdcall \galt\ cplusplus \galt\ jvm \galt\ dotnet}
  \gor{%
    \gverbal{system-specific calling conventions}}
  \grule[external entity]{entity}{%
    \gnterm{string}}
  \grule{safety}{%
    unsafe \galt\ safe}
\end{grammar}
%
There are two flavours of foreign declarations: import and export
declarations.  An import declaration makes an \emph{external entity,} i.e., a
function or memory location defined in an external context, available in the
Haskell context.  Conversely, an export declaration defines a function of the
Haskell context as an external entity in an external context.  Consequently,
the two types of declarations differ in that an import declaration defines a
new variable, whereas an export declaration uses a variable that is already
defined in the Haskell module.

The external context that contains the external entity is determined by the
calling convention specified in the foreign declaration.  Consequently, the
exact form of the specification of the external entity is dependent on both
the calling convention and on whether it appears in an import or export
declaration.  To provide syntactic uniformity in the presence of different
calling conventions, it is guaranteed that the description of an external
entity lexically appears as a Haskell string lexeme.

Note that the new keyword \code{foreign} is the only name taken away from the
Haskell 98 name space.  All other special identifiers that may appear in
foreign declarations do not have a special status outside of those
declarations.

\begin{verbatim}
FIXME: modifiers for concurrency control?
\end{verbatim}

\subsection{Calling Conventions}
\label{sec:call-conv}

The calling convention determines the binary interface to an external entity
on a given architecture.  It often depends on the programming language in
which the external entity is implemented, but usually is more dependent on the
system for which the external entity has been compiled.

As an example of how the calling convention is dominated by the system rather
than the programming language, consider that an entity compiled to byte code
for the Java Abstract Machine (JVM)~\cite{lindholm-etal:JVM} needs to be
invoked by the rules of the JVM rather than that of the source language in
which it is implemented (the entity might be implemented in Oberon, for
example).

Any implementation of the Haskell 98 FFI must at least implement the C calling
convention denoted by \code{ccall}.  All other calling conventions are
optional.  Generally, the set of calling conventions is open, i.e., individual
implementations may elect to support additional calling conventions.  In
addition to \code{ccall}, Table~\ref{tab:callconv} specifies a range of
identifiers for common calling conventions.
%
\begin{table}[tbp]
  \begin{center}
    \begin{tabular}{|l|l|}
      \hline
      Identifier & Represented calling convention\\
      \hline\hline
      \code{ccall} 
      & Calling convention of the standard C compiler on a system\\
      \code{cplusplus}
      & Calling convention of the standard C{+}{+} compiler on a system\\
      \code{dotnet}
      & Calling convention of the \textsc{.net} platform\\
      \code{jvm} 
      & Calling convention of the Java Abstract Machine\\
      \code{stdcall}
      & Calling convention of the Win32 API (matches Pascal conventions)\\
      \hline
    \end{tabular}
    \caption{Calling conventions}
    \label{tab:callconv}
  \end{center}
\end{table}
%
Implementations need not implement all of these conventions, but if any is
implemented, it must use the listed name.  For any other calling convention,
implementations are free to choose a suitable name.

It should be noted that the code generated by a Haskell system to implement a
particular calling convention may vary widely with the target code of that
system.  For example, the calling convention \code{jvm} will be trivial to
implement for a Haskell compiler generating Java code, whereas for a Haskell
compiler generating C code, the Java Native Interface (JNI)~\cite{liang:JNI}
has to be targeted.

\begin{verbatim}
FIXME: How many optional calling conventions should we specify here?
  What is the policy regarding calling conventions introduced by
  systems after this report is released?
\end{verbatim}

\subsection{Foreign Types}
\label{sec:foreign-types}

The following types constitute the set of \emph{basic foreign types}:
%
\begin{itemize}
\item \code{Char}, \code{Int}, \code{Double}, \code{Float}, and \code{Bool} as
  exported by the Haskell 98 \code{Prelude} as well as
\item \code{Int8}, \code{Int16}, \code{Int32}, \code{Int64}, \code{Word8},
  \code{Word16}, \code{Word32}, \code{Int64}, \code{Ptr a}, \code{FunPtr a},
  \code{ForeignPtr a}, and \code{StablePtr a}, for any type \code{a}, as
  exported by \code{Foreign} (Section~\ref{sec:Foreign}).
\end{itemize}
%
A Haskell system that implements the FFI needs to be able to pass these types
between the Haskell and the external context as function arguments and results
with the exception that values of type \code{ForeignPtr a} can only be passed
from Haskell to the external context and not in the opposite direction.

\begin{verbatim}
FIXME: Remove ForeignPtr from the list of basic foreign types.
  ** Will be removed in the next version unless their are complaints **
\end{verbatim}

Foreign types are produced according to the following grammar:
%
\begin{grammar}
  \grule{ftype}{%
    \gnterm{frtype}}
  \gor{%
    \gnterm{fatype} -> \gnterm{ftype}}
  \grule{frtype}{%
    \gnterm{fatype}}
  \gor{%
    ()}
  \grule[$k\geq0$]{fatype}{%
    \gnterm{qtycon} \gnterm[1]{atype} \gellipse\ \gnterm[k]{atype}}
\end{grammar}
%
A foreign type is the Haskell type of an external entity.  Only a subset of
Haskell's types are permissible as foreign types, as only a restricted set of
types can be reliably transferred between the Haskell context and an external
context.  A foreign type generally has the form
\[
\textit{at}_1\code{ -> }\cdots\code{ -> }\textit{at}_n\code{ -> }\textit{rt}
\]
where \(n\geq0\).  It implies that the arity of the external entity is $n$.

The argument types \(\textit{at}_i\) and result type \textit{rt} produced by
\gnterm{fatype} must be \emph{marshallable foreign types}.  A marshallable
foreign type is either (1) a basic foreign type or (2) a type synonym or
renamed datatype of a marshallable foreign type.  Moreover, the result type
\textit{rt} may also be a type matching \code{Prelude.IO }$t$, where $t$ is
a marshallable foreign type.

External functions are generally strict in all arguments.

\subsection{Import Declarations}
\label{sec:import}

Generally, an import declaration has the form
%
\[
\code{foreign}~\code{import}~c~e~v~\code{{::}}~t
\]
%
which declares the variable $v$ of type $t$ to be defined externally.
Moreover, it specifies that $v$ is evaluated by executing the external entity
identified by the string $e$ using calling convention $c$.  The precise form
of $e$ depends on the calling convention and is detailed in
Section~\ref{sec:extent}.  If a variable $v$ is defined by an import
declaration, no other top-level declaration for $v$ is allowed in the same
module.  For example, the declaration
%
\begin{quote}
\begin{verbatim}
foreign import ccall "string.h strlen" cstrlen :: Ptr CChar -> IO CSize
\end{verbatim}
\end{quote}
%
introduces the function \code{cstrlen}, which invokes the external function
\code{strlen} using the standard C calling convention.  Some external entities
can be imported as pure functions; for example,
%
\begin{quote}
\begin{verbatim}
foreign import ccall "math.h sin" sin :: CDouble -> CDouble.
\end{verbatim}
\end{quote}
%
Whether a particular form of external entity places a constraint on the
Haskell type with which it can be imported is defined in
Section~\ref{sec:extent}.  Although, some forms of external entities restrict
the set of Haskell types that are permissible, the system can generally not
guarantee the consistency between the Haskell type given in an import
declaration and the argument and result types of the external entity.  It is
the responsibility of the programmer to ensure this consistency.

Optionally, an import declaration can specify, after the calling convention,
the safety level that should be used when invoking an external entity.  A
\code{safe} call is less efficient, but guarantees to leave the Haskell system
in a state that allows callbacks from the external code.  In contrast, an
\code{unsafe} call, while carrying less overhead, may not trigger a callback
into the Haskell system.  If it does, the system behaviour is undefined.  The
default for an invocation is to be \code{safe}.  Note that a call back into
the Haskell system implies that a garbage collection might be triggered after
an external entity was called, but before this call returns.  Consequently,
objects other than stable pointers (cf.\ Section~\ref{sec:StablePtr}) may be
moved by the storage manager.

It is guaranteed that any argument passed to an external entity upon
invocation is kept alive by the Haskell storage manager until the call to the
external entity returns.  If an argument needs to be kept alive longer, a
stable pointer has to be used.

\subsection{Export Declarations}

The general form of export declarations is
%
\[
\code{foreign}~\code{export}~c~e~v~\code{{::}}~t
\]
%
Such a declaration enables external access to $v$, which may be a value, field
name, or class method that is declared on the top-level of the same module or
imported.  Moreover, the Haskell system defines the external entity described
by the string $e$, which may be used by external code using the calling
convention $c$; an external invocation of the external entity $e$ is
translated into evaluation of $v$.  The type $t$ must be an instance of the
type of $v$.  For example, we may have
%
\begin{quote}
\begin{verbatim}
foreign export ccall "addInt"   (+) :: Int   -> Int   -> Int
foreign export ccall "addFloat" (+) :: Float -> Float -> Float
\end{verbatim}
\end{quote}

If an evaluation triggered by an external invocation of an exported Haskell
value returns with an exception, the system behaviour is undefined.  Thus,
Haskell exceptions have to be caught within Haskell and explicitly marshalled
to the foreign code.


\section{Specification of External Entities}
\label{sec:extent}

Each foreign declaration has to specify the external entity that is accessed
or provided by that declaration.  The syntax and semantics of the notation
that is required to uniquely determine an external entity depends heavily on
the calling convention by which this entity is accessed.  For example, for the
calling convention \code{ccall}, a global label is sufficient.  However, to
uniquely identify a method in the calling convention \code{jvm}, type
information has to be provided.  For the latter, there is a choice between the
Java source-level syntax of types and the syntax expected by JNI---but,
clearly, the syntax of the specification of an external entity depends on the
calling convention and may be non-trivial.

Consequently, the FFI does not fix a general syntax for denoting external
entities, but requires \gnterm{entity} to appear as a Haskell \gnterm{string}
literal.  The formation rules for the values of these strings depend on the
calling convention and a Haskell system implementing a particular calling
convention will have to parse these strings in accordance with the calling
convention.

Generally, for more complex calling conventions, there is a choice between the
user-level syntax for identifying entities (e.g., Java or C{+}{+}) and the
system-level syntax (e.g., the type syntax of JNI or mangled C{+}{+},
respectively).  If such a choice exists, the user-level syntax is to be
preferred.  Not only because it is more user friendly, but also because the
system-level syntax may not be entirely independent of the particular
implementation of the foreign language.

The following defines the syntax for specifying external entities and their
semantics for each of the standard calling conventions listed in
Table~\ref{tab:callconv}.

\subsection{Standard C Calls}
\label{sec:ccall}

The following defines the structure of external entities for foreign
declarations under the \code{ccall} calling convention for both import and
export declarations separately.  Afterwards additional constraints on the type
of foreign functions are defined.

\subsubsection{Import Declarations}

For import declarations, the syntax for the specification of external entities
under the \code{ccall} calling convention is
%
\begin{grammar}
  \grule[static function or address]{entity}{%
    " \gopt{static} \gopt{\gnterm{fname}} \gopt{\&} 
    \gopt{[ \gnterm{lib} ]} \gopt{\gnterm{cid}} "}
  \gor[dynamically imports addresses]{%
    " dynamic "}
  \gor[dynamically exports thunks]{%
    " wrapper "}
  \grule{fname}{%
    \gverbal{file name with suffix `\code{.h}'}}
  \grule{lib}{%
    \gverbal{name of library archive}}
  \grule{cid}{%
    \gverbal{C identifier}}
\end{grammar}
%
The first alternative either imports a static function \gnterm{cid} or, if
\gterm\& precedes the identifier, a static address.  If \gnterm{cid} is
omitted, it defaults to the name of the imported Haskell variable.  The
optional filename \gnterm{fname} specifies a C header file and the optional
name \gnterm{lib}, which needs to be enclosed in square brackets, specifies a
library archive.  The range of lexemes that are admissible for \gnterm{fname}
and \gnterm{cid} coincides with the range of lexemes for arguments to the
\code{\#{}include} directive and C identifiers as defined in~\cite{C},
respectively.  The only exception is that the file name \gnterm{fname} must
end in the suffix \code{.h}.  The intended meaning is that \gnterm{fname} has
to be included to access \gnterm{cid}.  In particular, when the Haskell system
compiles Haskell to C code, the directive
%
\begin{quote}
  \gterm{\#include "\gnterm{fname}"}
\end{quote}
%
will be placed into any generated C file that refers to the foreign entity
before the first occurrence of that entity in the generated C file.  The
library name \gnterm{lib}, if provided, constitutes a hint as to which library
archive contains the code of the imported function at runtime.  The mapping of
the library name to a system-specific library archive is implementation
dependent.

The second and third alternative, identified by the keywords \gterm{dynamic}
and \gterm{wrapper}, respectively, import stub functions that have to be
generated by the Haskell system.  In the case of \gterm{dynamic}, the stub
converts C function pointers into Haskell functions; and conversely, in the
case of \gterm{wrapper}, the stub converts Haskell thunks to C function
pointers.

If neither of the specifiers \code{static}, \code{dynamic}, and \code{wrapper}
is given, \code{static} is assumed.  The specifier \code{static} is
nevertheless needed so that we can import C routines that are named
\code{dynamic} or \code{wrapper}.

\subsubsection{Export Declarations}

Moreover, external entities in \gnterm{ccall} export declarations are of the
form
%
\begin{grammar}
  \grule{entity}{%
    " \gopt{\gnterm{cid}} "}
\end{grammar}
%
The optional C identifier \gnterm{cid} defines the external name by which the
exported Haskell variable is accessible in C.  If it is omitted, the external
name defaults to the name of the exported Haskell variable.

\subsubsection{Constraints on Foreign Function Types}

In the case of import declaration, there are, depending on the kind of import
declaration, constraints regarding the admissible Haskell type that the
variable defined in the import may have.  These constraints are specified in
the following.
%
\begin{description}
\item[Static Functions.]  A static function can be of any foreign type; in
  particular, the result type may or may not be in the IO monad.  If a
  function that is not pure is not imported in the IO monad, the system
  behaviour is undefined.  Generally, no check for consistency with the C type
  of the imported label is performed.

\item[Static addresses.]  The type of an imported address is constrained to be
  of the form \code{Ptr }\textit{a} or \code{FunPtr }\textit{a}, where
  \textit{a} can be any type.

\item[Dynamic import.]  The type of a \gnterm{dynamic} stub has to be of the
  form \code{FunPtr }\textit{ft}\code{ -> }\textit{ft}, where \textit{ft} may
  be any foreign type.

\item[Dynamic wrapper.]  The type of a \gnterm{wrapper} stub has to be of the
  form \textit{ft}\code{ -> }\code{IO (FunPtr }\textit{ft}\code), where
  \textit{ft} may be any foreign type.
\end{description}

\begin{verbatim}
FIXME: Add one example for each item in the preceding description list.
\end{verbatim}

\subsection{Win32 API Calls}

The specification of external entities under the \code{stdcall} calling
convention is identical to that for standard C calls.

\subsection{C{+}{+} Calls}

The syntax for the specification of external entities under the
\code{cplusplus} calling convention is
%
\begin{verbatim}
FIXME
\end{verbatim}

\subsection{JVM Calls}

The syntax for the specification of external entities under the \code{jvm}
calling convention is 
%
\begin{grammar}
  \grule{entity}{%
    "\gnterm{jtype} \gnterm{jqid}(\gnterm{jtypes})"}
  \gor[constructor call]{%
    "new \gnterm{jqid}(\gnterm{jtypes})"}
  \grule[$n\geq0$]{jtypes}{%
    \gnterm[1]{jtype},\gellipse,\gnterm[n]{jtype}}
\end{grammar}
%
where \gnterm{jqid} is a qualified Java identifier and \gnterm{jtype} a Java
types as defined in~\cite{gosling-etal:Java}.

\begin{verbatim}
FIXME: 
- complete this
- force the inclusion of the return type in case of "new"?
\end{verbatim}

\subsection{.NET Calls}

The syntax for the specification of external entities under the \code{dotnet}
calling convention is
%
\begin{verbatim}
FIXME
\end{verbatim}


\newpage
\section{Marshalling}
\label{sec:marshalling}

In addition to the language extension discussed in previous sections, FFI
support includes a set of standard libraries, which ease portable use of
foreign functions as well as marshalling of compound structures.  Generally,
the marshalling of Haskell structures into a foreign representation and vice
versa can be implemented in either Haskell or the foreign language.  At least
where the foreign language is at a significantly lower level, e.g.\ C, there
are good reasons for doing the marshalling in Haskell:
%
\begin{itemize}
\item Haskell's lazy evaluation strategy would require any foreign code that
  attempts to access Haskell structures to force the evaluation of these
  structures before accessing them. This would lead to complicated code in the
  foreign language, but does not need any extra consideration when coding the
  marshalling in Haskell.
\item Despite the fact that marshalling code in Haskell tends to look like C
  in Haskell syntax, the strong type system still catches many errors that
  would otherwise lead to difficult-to-debug runtime faults.
\item Direct access to Haskell heap structures from a language like
  C---especially, when marshalling from C to Haskell, i.e., when Haskell
  structures are created---carries the risk of corrupting the heap, which
  usually leads to faults that are very hard to debug. (Paradox as it may
  seem, the cause for corrupted C structures is usually easier to locate, at
  least when a conventional debugger like gdb is at hand.)
\end{itemize}
%
Consequently, the Haskell FFI emphasises Haskell-side marshalling.

The interface to the marshalling libraries is provided by the module
\code{Foreign} plus a language-dependent module per supported language.  In
particular, the standard requires the availability of the module
\code{CForeign}, which simplifies portable interfacing with external C code.
Language-dependent modules, such as \code{CForeign}, generally provide Haskell
types representing the types of the foreign language using a representation
that is compatible with the foreign types as implemented by the default
implementation of the foreign language on the present architecture.  This is
especially important for languages where the standard leaves some aspects of
the implementation of basic types to the implementation.  For example, in C,
the size of the various integral types is not fixed.  Thus, to represent C
interfaces faithfully in Haskell, for each integral type in C, we need to have
an integral type in Haskell that is guaranteed to have the same size as the
corresponding C type.

In the following, the interface of the language independent support is
defined.  The interface for C-specific support is discussed in
Section~\ref{sec:c-marshalling}. 

\subsection{\code{Foreign}}
\label{sec:Foreign}

The module \code{Foreign} combines the interfaces of all modules providing
language-independent marshalling support.  These modules are \code{Int},
\code{Word}, \code{Ptr}, \code{ForeignPtr}, \code{StablePtr}, \code{Storable},
\code{MarshalAlloc}, \code{MarshalArray}, \code{MarshalError}, and
\code{MarshalUtils}.

\begin{verbatim}
NOTE: unsafePerformIO is essential to the FFI?  Export it from Foreign.
  (May also be exported by IOExts, but we might want to guarantee its
  availability.) (Maybe also unsafeInterleaveIO.)
** This note will disappear and `unsafePerformIO' being added to Foreign if
   there are no complaints **
Malcolm: yes
\end{verbatim}

\subsection{\code{Bits}}

\begin{verbatim}
NOTE: Shouldn't Bits be part of the FFI?  If so, IntN and WordN must have
  an instance for Bits, too.
** This note will disappear and `Bits' being added if there are no 
   complaints **
Malcolm: yes
\end{verbatim}

\subsection{\code{Int} and \code{Word}}
\label{sec:Int-Word}

The two modules \code{Int} and \code{Word} provide the following signed and
unsigned integral types of fixed size:
%
\begin{quote}
  \begin{tabular}{|l|l|l|}
    \hline
    Size in bits & Unsigned     & Signed\\\hline\hline
    8            & \code{Int8}  & \code{Word8}\\
    16           & \code{Int16} & \code{Word16}\\
    32           & \code{Int32} & \code{Word32}\\
    64           & \code{Int64} & \code{Word34}\\
    \hline
  \end{tabular}
\end{quote}
%
For these integral types, the modules \code{Int} and \code{Word} export class
instances for all types classes for which \code{Int} has an instance.  The
constraints on the implementation of these instances are also the same as
those outlined for \code{Int} in the Haskell Report.  There is, however, the
additional constraint that all arithmetic on the fixed-sized types is
performed modula \(2^n\).

\subsection{\code{Ptr}}
\label{sec:Ptr}

The module \code{Ptr} provides typed pointers to foreign data.  We distinguish
two kinds of pointers: pointers to data and pointers to functions.  It is
understood that these two kinds of pointers may be repesented differently as
they may be references to data and text segments, respectively.

\subsubsection{Data Pointers}

The interface defining data pointers and associated operations is as follows:
%
\begin{codedesc}
\item[data Ptr a] A value of type \code{Ptr a} represents a pointer to an
  object, or an array of objects, which may be marshalled to or from Haskell
  values of type \code{a}.  The type a will normally be an instance of class
  \code{Storable} (see Section~\ref{sec:Storable}), which provides the
  marshalling operations.

  Instances for the classes \code{Eq}, \code{Ord}, and \code{Show} are
  provided. 
\item[nullPtr ::\ Ptr a] The constant \code{nullPtr} contains a distinguished
  value of \code{Ptr} that is not associated with a valid memory location.
\item[castPtr ::\ Ptr a -> Ptr b] The \code{castPtr} function casts a pointer
  from one type to another.
\item[plusPtr ::\ Ptr a -> Int -> Ptr b] Advances the given address by the
  given offset in bytes.
\item[alignPtr ::\ Ptr a -> Int -> Ptr a] Given an arbitrary address and an
  alignment constraint, \code{alignPtr} yields an address, the same or next
  higher, that fulfills the alignment constraint. An alignment constraint
  \code{x} is fulfilled by any address divisible by \code{x}. This operation
  is idempotent.
\item[minusPtr ::\ Ptr a -> Ptr b -> Int] Computes the offset required to get
  from the first to the second argument.  We have
  %
  \begin{quote}
\begin{verbatim}
p2 == p1 `plusPtr` (p2 `minusPtr` p1)
\end{verbatim}
  \end{quote}
\end{codedesc}
%
It should be noted that the use of \code{Int} for pointer differences
essentially forces any implementation to represent \code{Int} in as many bits
as used in the representation of pointer values.

\subsubsection{Function Pointers}

The interface defining function pointers and associated operations is as
follows:
%
\begin{codedesc}
\item[data FunPtr a] A value of type \code{FunPtr a} is a pointer to a piece
  of code.  It may be the pointer to a C function or to a Haskell function
  created using wrapper stub as outlined in Section~\ref{sec:ccall}. For
  example,
  %
  \begin{quote}
\begin{verbatim}
type Compare = Int -> Int -> Bool
foreign export dynamic mkCompare :: Compare -> IO (FunPtr Compare)
\end{verbatim}
  \end{quote}
  
  Instances for the classes \code{Eq}, \code{Ord}, and \code{Show} are
  provided.
\item[nullFunPtr ::\ FunPtr a] The constant \code{nullFunPtr} contains a
  distinguished value of \code{FunPtr} that is not associated with a valid
  memory location.
\item[castFunPtr ::\ FunPtr a -> FunPtr b] Casts a \code{FunPtr} to a
  \code{FunPtr} of a different type.
\item[freeHaskellFunPtr ::\ FunPtr a -> IO ()] Releases the storage associated
  with the given \code{FunPtr}. This should be called whenever the return
  value from a foreign export dynamic function is no longer required;
  otherwise, the storage it uses will leak.
\end{codedesc}

Moreover, there are two functions that are only valid on architectures where
data and function pointers range over the same set of addresses.  Only where
bindings to external libraries are made whose interface already relies on this
assumption, should the use of \code{castFunPtrToPtr} and
\code{castPtrToFunPtr} be considered; otherwise, it is recommended to avoid
using these functions.
%
\begin{codedesc}
\item[castFunPtrToPtr ::\ FunPtr a -> Ptr b]
\item[castPtrToFunPtr ::\ Ptr a -> FunPtr b] \combineitems These two functions
  cast Ptrs to FunPtrs and vice versa.
\end{codedesc}

\subsection{\code{ForeignPtr}}
\label{sec:ForeignPtr}

The type \code{ForeignPtr} represents references to objects that are
maintained in a foreign language, i.e., objects that are not part of the data
structures usually managed by the Haskell storage manager. The essential
difference between \code{ForeignPtr}s and vanilla memory references of type
\code{Ptr} is that the former may be associated with finalisers.  A finaliser
is a routine that is invoked when the Haskell storage manager detects
that---within the Haskell heap and stack---there are no more references left
that are pointing to the \code{ForeignPtr}.  Typically, the finaliser will,
then, invoke routines in the foreign language that free the resources bound by
the foreign object.  

The type \code{ForeignPtr} is parameterised in the same way as \code{Ptr}
(cf.\ Section~\ref{sec:Ptr}).  The data type and associated operations have
the following signature and purpose:
%
\begin{codedesc}
\item[data ForeignPtr a] A value of type \code{ForeignPtr a} represents a
  pointer to an object, or an array of objects, which may be marshalled to or
  from Haskell values of type \code{a}.  The type a will normally be an
  instance of class \code{Storable} (see Section~\ref{sec:Storable}), which
  provides the marshalling operations.
  
  An instance for the class \code{Eq} is provided.
  
\item[newForeignPtr ::\ Ptr a -> IO () -> IO (ForeignPtr a)] Turns a plain
  memory reference into a foreign object by associating a finaliser---given by
  the monadic operation---with the reference. The finaliser will be executed
  after the last reference to the foreign object is dropped. Note that there
  is no guarantee on how soon the finaliser is executed after the last
  reference was dropped; this depends on the details of the Haskell storage
  manager. The only guarantee is that the finaliser runs before the program
  terminates.  
  
\item[addForeignPtrFinalizer ::\ ForeignPtr a -> IO () -> IO ()] This function
  adds another finaliser to the given foreign object. No guarantees are made
  on the order in which multiple finalisers for a single object are run.

\item[withForeignPtr ::\ ForeignPtr a -> (Ptr a -> IO b) -> IO b]
  
  This is a way to look at the pointer living inside a foreign object. This
  function takes a function which is applied to that pointer. The resulting
  \code{IO} action is then executed. The foreign object is kept alive at least
  during the whole action, even if it is not used directly inside. Note that
  it is not safe to return the pointer from the action and use it after the
  action completes.  All uses of the pointer should be inside the
  \code{withForeignPtr} bracket.

  More precisely, the foreign pointer may be finalised after
  \code{withForeignPtr} is finished if the first argument was the last
  occurrence of that foreign pointer.  Finalisation of the foreign pointer
  might render the pointer that is passed to the function useless.
  Consequently, this pointer cannot be used safely anymore after the
  \code{withForeignPtr} is finished, unless the function
  \code{touchForeignPtr} is used to explicitly keep the foreign pointer alove.
  
  This function is normally used for marshalling data to or from the object
  pointed to by the \code{ForeignPtr}, using the operations from the
  \code{Storable} class.

\item[foreignPtrToPtr ::\ ForeignPtr a -> Ptr a]
  
  This function extracts the pointer component of a foreign pointer. This is a
  potentially dangerous operation, as if the argument to
  \code{foreignPtrToPtr} is the last usage occurrence of the given foreign
  pointer, then its finaliser(s) will be run, which potentially invalidates
  the plain pointer just obtained.  Hence, \code{touchForeignPtr} must be used
  wherever it has to be guaranteed that the pointer lives on---i.e., has
  another usage occurrence.

  It should be noticed that this function does not need to be monadic when
  used in combination with \code{touchForeignPtr}.  Until the
  \code{foreignPtrToPtr} is executed, the thunk representing the suspended
  call keeps the foreign pointer alive.  Afterwards, the
  \code{touchForeignPtr} keeps the pointer alive.
  
  To avoid subtle coding errors, hand written marshalling code should
  preferably use \code{withForeignPtr} rather than combinations of
  \code{foreignPtrToPtr} and \code{touchForeignPtr}. However, the later
  routines are occasionally preferred in tool-generated marshalling code.
  
\item[touchForeignPtr ::\ ForeignPtr a -> IO ()] This function ensures that
  the foreign object in question is alive at the given place in the sequence
  of \code{IO} actions. In particular \code{withForeignPtr} does a
  \code{touchForeignPtr} after it executes the user action.
  
  This function can be used to express liveness dependencies between
  \code{ForeignPtr}s: for example, if the finalizer for one \code{ForeignPtr}
  touches a second \code{ForeignPtr}, then it is ensured that the second
  \code{ForeignPtr} will stay alive at least as long as the first. This can be
  useful when you want to manipulate interior pointers to a foreign structure:
  You can use \code{touchForeignObj} to express the requirement that the
  exterior pointer must not be finalized until the interior pointer is no
  longer referenced.
    
\item[castForeignPtr ::\ ForeignPtr a -> ForeignPtr b] This function casts a
  \code{ForeignPtr} parameterised by one type into another type.
\end{codedesc}

\begin{verbatim}
NOTE: Why do we only have Eq on ForeignPtr, but also Ord an Show on Ptr?
** This note will disappear and Ord and Show be added to ForeignPtr unless
   their are complaints **
Malcolm: yes
\end{verbatim}

\subsection{\code{StablePtr}}
\label{sec:StablePtr}

A \emph{stable pointer} is a reference to a Haskell expression that is
guaranteed not to be affected by garbage collection, i.e., it will neither be
deallocated nor will the value of the stable pointer itself change during
garbage collection (ordinary references may be relocated during garbage
collection).  Consequently, stable pointers can be passed to foreign code,
which can treat it as an opaque reference to a Haskell value.

The data type and associated operations have the following signature and
purpose:
%
\begin{codedesc}
\item[data StablePtr a] Values of this type represent a stable reference to a
  Haskell value of type \code{a}.  Note that a stable pointer may not be
  dereferenced with routines from the class \code{Storable} (in contrast to
  \code{Ptr} and \code{ForeignPtr}).  Any attempt to do so will lead to
  undefined behaviour.
  
\item[newStablePtr ::\ a -> IO (StablePtr a)] Creates a stable pointer
  referring to the given Haskell value.
  
\item[deRefStablePtr ::\ StablePtr a -> IO a] Obtains the Haskell value
  referenced by a stable pointer, i.e., the same value that was passed to the
  corresponding call to \code{makeStablePtr}.
  
\item[freeStablePtr ::\ StablePtr a -> IO ()] Dissolve the association between
  the stable pointer and the Haskell value. Afterwards, if the stable pointer
  is passed to \code{deRefStablePtr} or \code{freeStablePtr}, the behaviour is
  undefined.  However, the stable pointer may still be passed to
  \code{castStablePtrToPtr}, but the Ptr () value returned by
  \code{castStablePtrToPtr}, in this case, is undefined (in particular, it may
  be \code{Ptr.nullPtr}).  Nevertheless, the call is guaranteed not to
  diverge.
  
\item[castStablePtrToPtr ::\ StablePtr a -> Ptr ()] Coerces a stable pointer
  to an address. No guarantees are made about the resulting value, except that
  the original stable pointer can be recovered by \code{castPtrToStablePtr}.
  In particular, the address may not refer to a valid memory address and any
  attempt to pass it to the member functions of the class \code{Storable}
  (Section~\ref{sec:Storable}) leads to undefined behaviour.
  
\item[castPtrToStablePtr ::\ Ptr () -> StablePtr a] The inverse of
  \code{castStablePtrToPtr}, i.e., we have the identity
  %
  \begin{quote}
\begin{verbatim}
sp == castPtrToStablePtr (castStablePtrToPtr sp)
\end{verbatim}
  \end{quote}
  %
  for any stable pointer \code{sp} on which \code{freeStablePtr} has not been
  executed yet.
\end{codedesc}

It is important to free stable pointers that are no longer required by using
\code{freeStablePtr}.  Otherwise, the object referenced by the stable pointer
will be retained in the heap.


\subsection{\code{Storable}}
\label{sec:Storable}

To code marshalling in Haskell, Haskell data structures need to be translated
into the binary representation of a corresponding data structure of the
foreign language and vice versa.  To this end, the module \code{Storable}
provides routines that manipulate primitive data types stored in unstructured
memory blocks.  The class \code{Storable} is instantiated for all primitive
types that can be stored in raw memory.  Reading and writing these types to
arbitrary memory locations is implemented by the member functions of the
class.  The member functions, furthermore, encompass support for computing the
storage requirements and alignment restrictions of storable types.

Memory addresses are represented as values of type \code{Ptr a}
(Section~\ref{sec:Ptr}), where \code{a} is a storable type.  The type argument
to \code{Ptr} provides some type safety in marshalling code, as pointers to
different types cannot be mixed without an explicit cast.  Moreover, it
assists in resolving overloading.

The class \code{Storable} is instantiated for all standard basic types of
Haskell, the fixed size integral types of the modules \code{Int} and
\code{Word} (Section~\ref{sec:Int-Word}) , data and function pointers
(Section~\ref{sec:Ptr}), and stable pointers (Section~\ref{sec:StablePtr}).
There is no instance of \code{Storable} for foreign pointers.  The intention
is to ensure that storing a foreign pointer requires an explicit cast to a
plain \code{Ptr}, which makes it obvious that the finalisers of the foreign
pointer may be invoked at this point if no other reference to the pointer
exists anymore.

The signatures and behaviour of the member functions of the class
\code{Storable} are as follows:
%
\begin{codedesc}
\item[sizeOf~~~~::\ Storable a => a -> Int]
\item[alignment~::\ Storable a => a -> Int]\combineitems The function
  \code{sizeOf} computes the storage requirements (in bytes) of the argument,
  and alignment computes the alignment constraint of the argument.  An
  alignment constraint \code{x} is fulfilled by any address divisible by
  \code{x}. Both functions do not evaluate their argument, but compute the
  result on the basis of the type of the argument alone.

\item[peekElemOff ::\ Storable a => Ptr a -> Int -> IO a] Read a value from a
  memory area regarded as an array of values of the same kind. The first
  argument specifies the start address of the array and the second the index
  into the array (the first element of the array has index 0).
  
\item[pokeElemOff ::\ Storable a => Ptr a -> Int -> a -> IO ()] Write a value
  to a memory area regarded as an array of values of the same kind.  The first
  and second argument are as for \code{peekElemOff}.
  
\item[peekByteOff ::\ Storable a => Ptr a -> Int -> IO a] Read a value from a
  memory location given by a base address and byte offset from that base
  address.
  
\item[pokeByteOff ::\ Storable a => Ptr a -> Int -> a -> IO ()] Write a value
  to a memory location given by a base address and offset from that base
  address.
  
\item[peek ::\ Storable a => Ptr a -> IO a] Read a value from the given memory
  location.
  
\item[poke ::\ Storable a => Ptr a -> a -> IO ()] Write the given value to the
  given memory location.
\end{codedesc}
%
On some architectures, the \code{peek} and \code{poke} functions might require
properly aligned addresses to function correctly.  Thus, portable code should
ensure that when peeking or poking values of some type \code{a}, the alignment
constraint for \code{a}, as given by the function \code{alignment} is
fulfilled.

A minimal complete definition of \code{Storable} needs to define
\code{sizeOf}, \code{alignment}, one of \code{peek}, \code{peekElemOff}, or
\code{peekByteOff}, and one of \code{poke}, \code{pokeElemOff}, and
\code{pokeByteOff}.

\subsection{\code{MarshalAlloc}}
\label{sec:MarshalAlloc}

The module \code{MarshalAlloc} provides operations to allocate and deallocate
blocks of raw memory (i.e., unstructured chunks of memory outside of the area
maintained by the Haskell storage manager).  These memory blocks are commonly
used to pass compound data structures to foreign functions or to provide space
in which compound result values are obtained from foreign functions.  For
example, Haskell lists are typically passed as C arrays to C functions; the
storage space for such an array can be allocated by the following functions:
%
\begin{codedesc}
\item[malloc ::\ Storable a => IO (Ptr a)] Allocate a block of memory that is
  sufficient to hold values of type \code{a}.  The size of the memory area is
  determined by the function \code{Storable.sizeOf}
  (Section~\ref{sec:Storable}).

\item[mallocBytes ::\ Int -> IO (Ptr a)] Allocate a block of memory of the
  given number of bytes.
  
\item[alloca ::\ Storable a => (Ptr a -> IO b) -> IO b] Allocate a block of
  memory of the same size as \code{malloc}, but the reference is passed to a
  computation instead of being returned.  When the computation terminates,
  free the memory area again.  The operation is exception-safe; i.e.,
  allocated memory is freed if an exception is thrown in the marshalling
  computation.

\item[allocaBytes ::\ Int -> (Ptr a -> IO b) -> IO b] As \code{alloca}, but
  allocates a memory area of the given size.
  
\item[reallocBytes ::\ Ptr a -> Int -> IO (Ptr a)] Resize a memory area that
  was allocated with \code{malloc} or \code{mallocBytes} to the given size.

\item[free ::\ Ptr a -> IO ()] Free a block of memory that was allocated with
  \code{malloc} or \code{mallocBytes}.
\end{codedesc}
%
If any of allocation functions fails, a value of \code{Ptr.nullPtr} is
produced.  If \code{free} is applied to a memory area that has been allocated
with \code{alloca} or \code{allocaBytes}, the behaviour is undefined.
However, \code{reallocBytes} may be used on such memory areas.  Any further
access to memory areas allocated with \code{alloca} or \code{allocaBytes},
after the computation that was passed to the allocation function has
terminated, leads to undefined behaviour.

\subsection{\code{MarshalArray}}
\label{sec:MarshalArray}

The module \code{MarshalArray} provides operations for marshalling Haskell
lists into monolithic arrays and vice versa.  Most functions come in two
flavours: one for arrays terminated by a special termination element and one
where an explicit length parameter is used to determine the extent of an
array.  The typical example for the former case are C's NUL terminated
strings.  However, please note that C strings should usually be marshalled
using the functions provided by \code{CString} (Section~\ref{sec:CString}) as
the Unicode encoding has to be taken into account.  All functions specifically
operating on arrays that are terminated by a special termination element have
a name ending on \code{0}---e.g., \code{mallocArray} allocates space for an
array of the given size, whereas \code{mallocArray0} allocates space for one
more element to ensure that there is room for the terminator.

The following functions are provided by the module:
%
\begin{codedesc}
\item[mallocArray~~::\ Storable a => Int -> IO (Ptr a)]
\item[allocaArray~~::\ Storable a => Int -> (Ptr a -> IO b) -> IO b]
  \combineitems
\item[reallocArray~::\ Storable a => Ptr a -> Int -> IO (Ptr a)]\combineitems
  The functions behave like the functions \code{malloc}, \code{alloca}, and
  \code{realloc} provided by the module \code{MarshalAlloc}
  (Section~\ref{sec:MarshalAlloc}), respectively, except that they allocate a
  memory area that can hold an array of elements of the given length, instead
  of storage for just a single element.  

\item[mallocArray0~~::\ Storable a => Int -> IO (Ptr a)]
\item[allocaArray0~~::\ Storable a => Int -> (Ptr a -> IO b) -> IO b]\combineitems
\item[reallocArray0~::\ Storable a => Ptr a -> Int -> IO (Ptr a)]\combineitems
  These functions are like the previous three functions, but reserve storage
  space for one additional array element to allow for a termination indicator.
  
\item[peekArray ::\ Storable a => Int -> Ptr a -> IO {[a]}] Marshal an array of
  the given length and starting at the address indicated by the pointer
  argument into a Haskell list using \code{Storable.peekElemOff} to obtain the
  individual elements.  The order of elements in the list matches the order in
  the array.
  
\item[pokeArray ::\ Storable a => Ptr a -> {[a]} -> IO ()] Marshal the elements
  of the given list into an array whose start address is determined by the
  first argument using \code{Storable.pokeElemOff} to write the individual
  elements.  The order of elements in the array matches that in the list.
  
\item[peekArray0 ::\ (Storable a, Eq a) => a -> Ptr a -> IO {[a]}] Marshal an
  array like \code{peekArray}, but instead of the length of the array a
  terminator element is specified by the first argument.  All elements of the
  array, starting with the first element, up to, but excluding the first
  occurrence of an element that is equal (as determined by \code{==}) to the
  terminator are marshalled.

\item[pokeArray0 ::\ Storable a => a -> Ptr a -> {[a]} -> IO ()]
  Marshal an array like \code{pokeArray}, but write a terminator value
  (determined by the first argument) after the last element of the list.  Note
  that the terminator must not occur in the marshalled list if it should be
  possible to extract the list with \code{peekArray0}.

\item[newArray~~::\ Storable a => {[a]} -> IO (Ptr a)]
\item[withArray~::\ Storable a => {[a]} -> (Ptr a -> IO b) -> IO b]\combineitems
  These two functions combine \code{mallocArray} and \code{allocaArray},
  respectively, with \code{pokeArray}; i.e., they allocate a memory area for
  an array whose length matches that of the list, and then, marshal the list
  into that memory area.

\item[newArray0~~::\ Storable a => a -> {[a]} -> IO (Ptr a)]
\item[withArray0~::\ Storable a => a -> {[a]} -> (Ptr a -> IO b) -> IO b]\combineitems
  These two functions combine \code{mallocArray0} and \code{allocaArray0},
  respectively, with \code{pokeArray0}; i.e., they allocate a memory area for
  an array whose length matches that of the list, and then, marshal the list
  into that memory area.  The first argument determines the terminator.

\item[copyArray ::\ Storable a => Ptr a -> Ptr a -> Int -> IO ()]
\item[moveArray ::\ Storable a => Ptr a -> Ptr a -> Int -> IO ()]\combineitems
  These two functions copy entire arrays and behave like the routines
  \code{MarshalUtils.copyBytes} and \code{MarshalUtils.moveBytes},
  respectively (Section~\ref{sec:MarshalUtils}).  In particular,
  \code{moveArray} allows the source and destination array to overlap, whereas
  \code{copyArray} does not allow overlapping arrays.  Both functions take a
  reference to the destination array as their first, and a reference to the
  source as their second argument.  However, in contrast to the routines from
  \code{MarshalUtils} the third argument here specifies the number of array
  elements (whose type is specified by the parametrised pointer arguments)
  instead of the number of bytes to copy.
  
\item[lengthArray0 ::\ (Storable a, Eq a) => a -> Ptr a -> IO Int] Determine
  the length of an array whose end is marked by the first occurrence of the
  given terminator (first argument). The length is measured in array elements
  (not bytes) and does not include the terminator.
  
\item[advancePtr ::\ Storable a => Ptr a -> Int -> Ptr a] Advance a reference
  to an array by as many array elements (not bytes) as specified.
\end{codedesc}

\subsection{\code{MarshalError}}
\label{sec:MarshalError}

The module \code{MarshalError} provides language independent routines for
converting error conditions of external functions into Haskell IO monad
exceptions.
%
\begin{codedesc}
\item[throwIf ::\ (a -> Bool) -> (a -> String) -> IO a -> IO a] Execute the
  computation determined by the third argument.  If the predicate provided in
  the first argument yields \code{True} when applied to the result of that
  computation, raise an \code{IO} exception that includes an error message
  obtained by applying the second argument to the result of the computation.
  If no exception is raised, the result of the computation is the result of
  the whole operation.

\item[throwIf\_ ::\ (a -> Bool) -> (a -> String) -> IO a -> IO ()]
  Operate as \code{throwIf} does, but discard the result of the computation
  in any case.

\item[throwIfNeg~~::\ (Ord a, Num a) => (a -> String) -> IO a -> IO a]
\item[throwIfNeg\_~::\ (Ord a, Num a) => (a -> String) -> IO a -> IO ()]\combineitems
  These two functions are instances of \code{throwIf} and \code{throwIf\_},
  respectively, where the predicate is \code{(< 0)}.
  
\item[throwIfNull ::\ String -> IO (Ptr a) -> IO (Ptr a)] This is an instance
  of \code{throwIf}, where the predicate is \code{(== Ptr.nullPtr)} and the
  error message is constant.

\item[void ::\ IO a -> IO ()]
  Discard the result of a computation.
\end{codedesc}

\subsection{\code{MarshalUtils}}
\label{sec:MarshalUtils}

Finally, the module \code{MarshalUtils} provides a set of useful auxilliary
routines. 
%
\begin{codedesc}
\item[new ::\ Storable a => a -> IO (Ptr a)] This function first applies
  \code{MarshalAlloc.malloc} (Section~\ref{sec:MarshalAlloc}) to its
  argument, and then, stores the argument in the newly allocated memory area
  using \code{Storable.poke} (Section~\ref{sec:Storable}).
  
\item[with ::\ Storable a => a -> (Ptr a -> IO b) -> IO b] This function is
  like \code{new}, but uses \code{MarshalAlloc.alloca} instead of
  \code{MarshalAlloc.malloc}.

\item[fromBool~::\ Num a => Bool -> a]
\item[toBool~~~::\ Num a => a -> Bool]\combineitems These two functions
  implement conversions between Haskell Boolean values and numeric
  representations of Boolean values, where \code{False} is represented by
  \code{0} and \code{True} by any non-zero value.

\item[maybeNew ::\ (a -> IO (Ptr a)) -> (Maybe a -> IO (Ptr a))]
  Lift a function that marshals a value of type \code{a} to a function that
  marshals a value of type \code{Maybe a}.  In case, where the latter is
  \code{Nothing}, return \code{Ptr.nullPtr} (Section~\ref{sec:Ptr})

\item[maybeWith ::\ (a -> (Ptr b -> IO c) -> IO c)%
  -> (Maybe a -> (Ptr b -> IO c) -> IO c)] This function lifts a
  \code{MarshalAlloc.alloca} based marshalling function for \code{a} to
  \code{Maybe a}.  It marshals values \code{Nothing} in the same way as
  \code{maybeNew}. 
  
\item[maybePeek ::\ (Ptr a -> IO b) -> (Ptr a -> IO (Maybe b))] Given a
  function that marshals a value stored in the referenced memory area to a
  value of type \code{b}, lift it to producing a value of type \code{Maybe b}.
  If the pointer is \code{Ptr.nullPtr}, produce \code{Nothing}.
  
% Move to `Data.List.withMany' in new library spec.
%\item[withMany ::\ (a -> (b -> res) -> res) -> {[a]} -> ({[b]} -> res) -> res]
%  Lift a marshalling function of the \code{with} family to operate on a list
%  of values.

\item[copyBytes ::\ Ptr a -> Ptr a -> Int -> IO ()]
\item[moveBytes ::\ Ptr a -> Ptr a -> Int -> IO ()]\combineitems These two
  functions are Haskell variants of the standard C library routines
  \code{memcpy()} and \code{memmove()}, respectively.  As with their C
  counterparts, \code{moveBytes} allows the source and destination array to
  overlap, whereas \code{copyBytes} does not allow overlapping areas.  Both
  functions take a reference to the destination area as their first, and a
  reference to the source as their second argument---i.e., the argument order
  is as in an assignment.
\end{codedesc}

\newpage
\section{C-Specific Marshalling}
\label{sec:c-marshalling}

\subsection{\code{CForeign}}
\label{sec:CForeign}

The module \code{CForeign} combines the interfaces of all modules providing
C-specific marshalling support.  The modules are \code{CTypes},
\code{CTypesISO}, \code{CString}, and \code{CError}.

\begin{table}
  \begin{center}
    \begin{tabular}{|l|l|l|}
      \hline
      C symbol          & Haskell symbol & Constraint on concrete C type\\
      \hline\hline
      \code{HsChar}     & \code{Char}    
      & integral type\\
      \hline
      \code{HsInt}      & \code{Int}
      & signed integral type, $\geq30$ bit\\
      \hline
      \code{HsInt8}     & \code{Int8}
      & signed integral type, 8 bit; \code{int8\_t} if available\\
      \hline
      \code{HsInt16}    & \code{Int16}
      & signed integral type, 16 bit; \code{int16\_t} if available\\
      \hline
      \code{HsInt32}    & \code{Int32}
      & signed integral type, 32 bit; \code{int32\_t} if available\\
      \hline
      \code{HsInt64}    & \code{Int64}
      & signed integral type, 64 bit; \code{int64\_t} if available\\ 
      \hline
      \code{HsWord8}    & \code{Word8}
      & unsigned integral type, 8 bit; \code{uint8\_t} if available\\
      \hline
      \code{HsWord16}   & \code{Word16}
      & unsigned integral type, 16 bit; \code{uint16\_t} if available\\
      \hline
      \code{HsWord32}   & \code{Word32}
      & unsigned integral type, 32 bit; \code{uint32\_t} if available\\
      \hline
      \code{HsWord64}   & \code{Word64}
      & unsigned integral type, 64 bit; \code{uint64\_t} if available\\
      \hline
      \code{HsFloat}    & \code{Float}
      & floating point type\\
     \hline
      \code{HsDouble}   & \code{Double}
      & floating point type\\
     \hline
      \code{HsBool}     & \code{Bool}
      & integral type\\
     \hline
      \code{HsPtr}      & \code{Ptr a}
      & \code{(void *)}\\
     \hline
      \code{HsFunPtr}   & \code{FunPtr a}
      & \code{(void (*)(void))}\\
     \hline
      \code{HsForeignPtr}& \code{ForeignPtr a}
      & \code{(void *)}\\
     \hline
      \code{HsStablePtr}& \code{StablePtr a}
      & \code{(void *)}\\
     \hline
    \end{tabular}
    \caption{C Interface to Basic Haskell Types}
    \label{tab:c-haskell-types}
  \end{center}
\end{table}
%
\begin{table}
  \begin{center}
%    \begin{tabular}{|l|l|l|}
    \begin{tabular}{|l|l|p{30ex}|}
      \hline
      C symbol           & Haskell value & Description\\
      \hline\hline
      \code{HS\_CHAR\_MIN} & \code{minBound ::\ Char}
      & \\
      \hline
      \code{HS\_CHAR\_MAX} & \code{maxBound ::\ Char}
      & \\
      \hline
      \code{HS\_INT\_MIN} & \code{minBound ::\ Int}
      & \\
      \hline
      \code{HS\_INT\_MAX} & \code{maxBound ::\ Int}
      & \\
      \hline
      \code{HS\_INT8\_MIN} & \code{minBound ::\ Int8}
      & \\
      \hline
      \code{HS\_INT8\_MAX} & \code{maxBound ::\ Int8}
      & \\
      \hline
      \code{HS\_INT16\_MIN} & \code{minBound ::\ Int16}
      & \\
      \hline
      \code{HS\_INT16\_MAX} & \code{maxBound ::\ Int16}
      & \\
      \hline
      \code{HS\_INT32\_MIN} & \code{minBound ::\ Int32}
      & \\
      \hline
      \code{HS\_INT32\_MAX} & \code{maxBound ::\ Int32}
      & \\
      \hline
      \code{HS\_INT64\_MIN} & \code{minBound ::\ Int64}
      & \\
      \hline
      \code{HS\_INT64\_MAX} & \code{maxBound ::\ Int64}
      & \\
      \hline
      \code{HS\_WORD8\_MAX} & \code{maxBound ::\ Word8}
      & \\
      \hline
      \code{HS\_WORD16\_MAX} & \code{maxBound ::\ Word16}
      & \\
      \hline
      \code{HS\_WORD32\_MAX} & \code{maxBound ::\ Word32}
      & \\
      \hline
      \code{HS\_WORD64\_MAX} & \code{maxBound ::\ Word64}
      & \\
      \hline
      \code{HS\_FLOAT\_RADIX} & \code{floatRadix ::\ Float}
      & \\
      \hline
      \code{HS\_FLOAT\_ROUND} & n/a
      & rounding style as per~\cite{C99}\\
      \hline
      \code{HS\_FLOAT\_EPSILON} & n/a
      & difference between 1 and the least value greater
      than 1 as per~\cite{C99}\\
      \hline
      \code{HS\_DOUBLE\_EPSILON} & n/a
      & (as above)\\
      \hline
      \code{HS\_FLOAT\_DIG} & n/a
      & number of decimal digits as per~\cite{C99}\\
      \hline
      \code{HS\_DOUBLE\_DIG} & n/a
      & (as above)\\
      \hline
      \code{HS\_FLOAT\_MANT\_DIG} & \code{floatDigits ::\ Float}
      & \\
      \hline
      \code{HS\_DOUBLE\_MANT\_DIG} & \code{floatDigits ::\ Double}
      & \\
      \hline
      \code{HS\_FLOAT\_MIN} & n/a
      & minimum floating point number as per~\cite{C99}\\
      \hline
      \code{HS\_DOUBLE\_MIN} & n/a
      & (as above)\\
      \hline
      \code{HS\_FLOAT\_MIN\_EXP} & \code{fst .\ floatRange ::\ Float}
      & \\
      \hline
      \code{HS\_DOUBLE\_MIN\_EXP} & \code{fst .\ floatRange ::\ Double}
      & \\
      \hline
      \code{HS\_FLOAT\_MIN\_10\_EXP} & n/a
      & minimum decimal exponent as per~\cite{C99}\\
      \hline
      \code{HS\_DOUBLE\_MIN\_10\_EXP} & n/a
      & (as above)\\
      \hline
      \code{HS\_FLOAT\_MAX} & n/a
      & maximum floating point number as per~\cite{C99}\\
      \hline
      \code{HS\_DOUBLE\_MAX} & n/a
      & (as above)\\
      \hline
      \code{HS\_FLOAT\_MAX\_EXP} & \code{snd .\ floatRange ::\ Float}
      & \\
      \hline
      \code{HS\_DOUBLE\_MAX\_EXP} & \code{snd .\ floatRange ::\ Double}
      & \\
      \hline
      \code{HS\_FLOAT\_MAX\_10\_EXP} & n/a
      & maximum decimal exponent as per~\cite{C99}\\
      \hline
      \code{HS\_DOUBLE\_MAX\_10\_EXP} & n/a
      & (as above)\\
      \hline
      \code{0} & \code{False}
      & \\
      \hline
      \code{1} & \code{True}
      & \\
      \hline
    \end{tabular}
    \caption{C Interface to Range and Precision of Basic Types}
    \label{tab:c-haskell-values}
  \end{center}
\end{table}
%
Every Haskell system that implements the FFI needs to provide a C header file
named \code{HsFFI.h} that defines the C symbols listed in
Tables~\ref{tab:c-haskell-types} and~\ref{tab:c-haskell-values}.
Table~\ref{tab:c-haskell-types} table lists symbols that represent types
together with the Haskell type that they represent and any constraints that
are placed on the concrete C types that implement these symbols.  When a C
type \code{HsT} represents a Haskell type \code{T}, the occurrence of \code{T}
in a foreign function declaration should be matched by \code{HsT} in the
corresponding C function prototype.  Indeed, where the Haskell system
translates Haskell to C code that invokes \code{foreign} \code{import}ed C
routines, such prototypes need to be provided and included via the header that
can be specified in external entity strings for foreign C functions (cf.\ 
Section~\ref{sec:ccall}); otherwise, the system behaviour is undefined.

Table~\ref{tab:c-haskell-values} contains symbols characterising the range and
precision of the types from Table~\ref{tab:c-haskell-types}.  Where available,
the table states the corresponding Haskell values.  All C symbols, except
\code{HS\_FLOAT\_ROUND} are constants that are suitable for use in \code{\#if}
preprocessing directives.  Note that there is only one rounding style
(\code{HS\_FLOAT\_ROUND}) and one radix (\code{HS\_FLOAT\_RADIX}), as this is
all that is supported by~\cite{C99}.

Moreover, an implementation that does not support 64 bit integral types on the
C side should implement \code{HsInt64} and \code{HsWord64} as a structure.  In
this case, the bounds \code{HS\_INT64\_MIN}, \code{HS\_INT64\_MAX}, and
\code{HS\_WORD64\_MAX} are undefined.

\begin{verbatim}
FIXME: Include into HsFFI.h a function such as GHC's startupHaskell().  It is
  called haskellInit().  What name do we choose?  I think, it should have a
  "ffi_" or "hs_" prefix.  Arguments as with GHC?  (What arguments does the
  NHC version have?)
\end{verbatim}

\subsection{\code{CTypes}}
\label{sec:CTypes}

The modules \code{CTypes} provide Haskell types that represent basic C types.
They are needed to accurately represent C function prototypes, and so, to
access C library interfaces in Haskell.  The Haskell system is not required to
represent those types exactly as C does, but the following guarantees are
provided concerning a Haskell type \code{CT} representing a C type \code{t}:
%
\begin{itemize}
\item If a C function prototype has \code{t} as an argument or result type,
  the use of \code{CT} in the corresponding position in a foreign declaration
  permits the Haskell program to access the full range of values encoded by
  the C type; and conversely, any Haskell value for \code{CT} has a valid
  representation in C.
\item \code{Storable.sizeOf (undefined ::\ T)} will yield the same value as
  \code{sizeof (t)} in C.
\item \code{Storable.alignment (undefined ::\ T)} matches the alignment
  constraint enforced by the C implementation for \code{t}.
\item \code{Storable.peek} and \code{Storable.poke} map all values of
  \code{CT} to the corresponding value of \code{t} and vice versa.
\item When an instance of \code{Bounded} is defined for \code{CT}, the values
  of \code{minBound} and \code{maxBound} coincide with \code{t\_MIN} and
  \code{t\_MAX} in C.
\item When an instance of \code{Eq} or \code{Ord} is defined for \code{CT},
  the predicates defined by the type class implement the same relation as the
  corresponding predicate in C on \code{t}.
\item When an instance of \code{Num}, \code{Read}, \code{Integral},
  \code{Fractional}, \code{Floating}, \code{RealFrac}, or \code{RealFloat} is
  defined for \code{CT}, the arithmetic operations defined by the type class
  implement the same function as the corresponding arithmetic operations (if
  available) in C on \code{t}.
\item When an instance of \code{Bits} is defined for \code{CT}, the logical
  operation defined by the type class implement the same function as the
  corresponding logical relation in C on \code{t}.
\end{itemize}
%
It follows from these guarantees that all types exported by \code{CTypes} are
represented as type synonyms or \code{newtype}s of basic foreign types as
defined in Section~\ref{sec:foreign-types}.

The module \code{CTypes} provides the following integral types, including
instances for \code{Eq}, \code{Ord}, \code{Num}, \code{Read}, \code{Show},
\code{Enum}, \code{Storable}, \code{Bounded}, \code{Real}, \code{Integral},
and \code{Bits}:
%
\begin{quote}
  \begin{tabular}{|l|l|l|}
    \hline
    Haskell type     & Represented C type\\\hline\hline
    \code{CChar}     & \code{char}\\\hline
    \code{CSChar}    & \code{signed char}\\\hline
    \code{CUChar}    & \code{unsigned char}\\\hline
    \code{CShort}    & \code{short}\\\hline
    \code{CUShort}   & \code{unsigned short}\\\hline
    \code{CInt}      & \code{int}\\\hline
    \code{CUInt}     & \code{unsigned int}\\\hline
    \code{CLong}     & \code{long}\\\hline
    \code{CULong}    & \code{unsigned long}\\\hline
    \code{CLLong}    & \code{long long}\\\hline
    \code{CULLong}   & \code{unsigned long long}\\\hline
  \end{tabular}
\end{quote}
%
Moreover, it provides the following floating point types, including instances
for \code{Eq}, \code{Ord}, \code{Num}, \code{Read}, \code{Show}, \code{Enum},
\code{Storable}, \code{Real}, \code{Fractional}, \code{Floating},
\code{RealFrac}, and \code{RealFloat}.
%
\begin{quote}
  \begin{tabular}{|l|l|l|}
    \hline
    Haskell type     & Represented C type\\\hline\hline
    \code{CFloat}    & \code{float}\\\hline
    \code{CDouble}   & \code{double}\\\hline
    \code{CLDouble}  & \code{long double}\\\hline
  \end{tabular}
\end{quote}

Moreover, the module provides the following integral types, including
instances for \code{Eq}, \code{Ord}, \code{Num}, \code{Read}, \code{Show},
\code{Enum}, \code{Storable}, \code{Bounded}, \code{Real}, \code{Integral},
and \code{Bits}:
%
\begin{quote}
  \begin{tabular}{|l|l|l|}
    \hline
    Haskell type     & Represented C type\\\hline\hline
    \code{CPtrdiff}  & \code{ptrdiff\_t}\\\hline
    \code{CSize}     & \code{size\_t}\\\hline
    \code{CWChar}    & \code{wchar\_t}\\\hline
    \code{CSigAtomic}& \code{sig\_atomic\_t}\\\hline
  \end{tabular}
\end{quote}
%
Moreover, it provides the following numeric point types, including instances
for \code{Eq}, \code{Ord}, \code{Num}, \code{Read}, \code{Show}, \code{Enum},
and \code{Storable}:
%
\begin{quote}
  \begin{tabular}{|l|l|l|}
    \hline
    Haskell type     & Represented C type\\\hline\hline
    \code{CClock}    & \code{clock\_t}\\\hline
    \code{CTime}     & \code{time\_t}\\\hline
  \end{tabular}
\end{quote}
%
And finally, the following types, including instances for \code{Eq} and
\code{Storable}:
%
\begin{quote}
  \begin{tabular}{|l|l|l|}
    \hline
    Haskell type     & Represented C type\\\hline\hline
    \code{CFile}     & \code{FILE}\\\hline
    \code{CFpos}     & \code{fpos\_t}\\\hline
    \code{CJmpBuf}   & \code{jmp\_buf}\\\hline
  \end{tabular}
\end{quote}

\subsection{\code{CString}}
\label{sec:CString}

The module \code{CString} provides routines marshalling Haskell into C strings
and vice versa.  The marshalling takes the current Unicode encoding on the
Haskell side into account.  As a consequence, no guarantees can be made about
the relative length of a Haskell string and its corresponding C string, and
therefore, all routines provided by \code{CString} combine memory allocation
and marshalling.
%
\begin{codedesc}
\item[CString = Ptr CChar] A C string is a reference to an array of C
  characters terminated by NUL.

\item[CStringLen = (CString, Int)] In addition to NUL-terminated strings,
  the module \code{CString} also supports strings with explicit length
  information. 

\item[peekCString~~~~::\ CString~~~~-> IO String]
\item[peekCStringLen~::\ CStringLen~-> IO String]\combineitems
  Marshal a C string to Haskell.  There are two variants of the routine, one
  for each supported string representation.

\item[newCString~~~~::\ String -> IO CString]
\item[newCStringLen~::\ String -> IO CStringLen] \combineitems Allocate a
  memory area for a Haskell string and marshal the string into its C
  representation.  There are two variants of the routine, one for each
  supported string representation.

\item[withCString~~~~::\ String -> (CString~~~~-> IO a) -> IO a]
\item[withCStringLen~::\ String -> (CStringLen~-> IO a) -> IO a] \combineitems
  These two routines operate as \code{newCString} and \code{newCStringLen},
  respectively, but handle memory allocation and deallocation like
  \code{MarshalAlloc.alloca} (Section~\ref{sec:MarshalAlloc}).

\item[castCharToCChar ::\ Char -> CChar]
\item[castCCharToChar ::\ CChar -> Char] \combineitems These two functions cast
  Haskell characters to C characters and vice versa while ignoring the Unicode
  encoding of the Haskell character.  These functions should be used with
  care.
\end{codedesc}

\subsection{\code{CError}}
\label{sec:CError}

The module CError facillitates C-specific error handling of \code{errno}.  In
Haskell, we represent values of \code{errno} by
%
\begin{quote}
\begin{verbatim}
newtype Errno = Errno CInt
\end{verbatim}
\end{quote}
%
which has an instance for the type class \code{Eq}.  The implementation of
\code{Errno} is disclosed on purpose.  Different operating systems and/or C
libraries often support different values of \code{errno}.  This module defines
the common values, but due to the open definition of \code{Errno} users may
add definitions which are not predefined.  The predefined values are the
following:
%
\begin{quote}
\begin{verbatim}
eOK, e2BIG, eACCES, eADDRINUSE, eADDRNOTAVAIL, eADV, eAFNOSUPPORT, eAGAIN, 
  eALREADY, eBADF, eBADMSG, eBADRPC, eBUSY, eCHILD, eCOMM, eCONNABORTED, 
  eCONNREFUSED, eCONNRESET, eDEADLK, eDESTADDRREQ, eDIRTY, eDOM, eDQUOT, 
  eEXIST, eFAULT, eFBIG, eFTYPE, eHOSTDOWN, eHOSTUNREACH, eIDRM, eILSEQ, 
  eINPROGRESS, eINTR, eINVAL, eIO, eISCONN, eISDIR, eLOOP, eMFILE, eMLINK, 
  eMSGSIZE, eMULTIHOP, eNAMETOOLONG, eNETDOWN, eNETRESET, eNETUNREACH, 
  eNFILE, eNOBUFS, eNODATA, eNODEV, eNOENT, eNOEXEC, eNOLCK, eNOLINK, 
  eNOMEM, eNOMSG, eNONET, eNOPROTOOPT, eNOSPC, eNOSR, eNOSTR, eNOSYS, 
  eNOTBLK, eNOTCONN, eNOTDIR, eNOTEMPTY, eNOTSOCK, eNOTTY, eNXIO, 
  eOPNOTSUPP, ePERM, ePFNOSUPPORT, ePIPE, ePROCLIM, ePROCUNAVAIL, 
  ePROGMISMATCH, ePROGUNAVAIL, ePROTO, ePROTONOSUPPORT, ePROTOTYPE, 
  eRANGE, eREMCHG, eREMOTE, eROFS, eRPCMISMATCH, eRREMOTE, eSHUTDOWN, 
  eSOCKTNOSUPPORT, eSPIPE, eSRCH, eSRMNT, eSTALE, eTIME, eTIMEDOUT, 
  eTOOMANYREFS, eTXTBSY, eUSERS, eWOULDBLOCK, eXDEV
  :: Errno
\end{verbatim}
\end{quote}
%
The meaning of these values corresponds to that of the C constants of the same
name---after dropping the leading ``e''.

The module \code{CError} provides the following functions:
%
\begin{codedesc}
\item[isValidErrno ::\ Errno -> Bool] Yield \code{True} if the given
  \code{Errno} value is valid on the system.  This implies that the \code{Eq}
  instance of \code{Errno} is also system dependent as it is only defined for
  valid values of \code{Errno}.

\item[getErrno ::\ IO Errno] Get the current value of \code{errno}.

\item[resetErrno ::\ IO ()] Reset \code{errno} to \code{eOK}.
  
\item[errnoToIOError ::\ String -> Errno -> Maybe Handle -> Maybe String ->
  IOError] Throw an \code{IO} exception based on the given \code{Errno} value.
  The first argument to the function should specify the location where the
  error occurred and the third and fourth can be used to specify a file handle
  and filename in the course of whose manipulation the error occurred.  This is
  optional information, which can be used to improve the accuracy of error
  messages.  
  
\item[throwErrno ::\ String -> IO a] Apply \code{errnoToIOError} to the value
  currently returned by \code{getErrno}.  Its first argument specifies the
  location---no extra information about a file handle or filename can be
  provided in this case.

\item[throwErrnoIf~~:: (a -> Bool) -> String -> IO a -> IO a]
\item[throwErrnoIf\_~:: (a -> Bool) -> String -> IO a -> IO ()]\combineitems
  Behave like \code{throwErrno} in case that the result of the \code{IO}
  action fulfils the predicate passed as a first argument.  The second variant
  discards the result after error handling.

\item[throwErrnoIfRetry~~:: (a -> Bool) -> String -> IO a -> IO a]
\item[throwErrnoIfRetry\_~:: (a -> Bool) -> String -> IO a -> IO ()]%
\combineitems Like \code{throwErrnoIf} and \code{throwErrnoIf\_}, but retry
the \code{IO} action when it yields the error code \code{eINTR}---this amounts
to the standard retry loop for interrupted POSIX system calls.

\item[throwErrnoIfMinus1~~:: Num a => String -> IO a -> IO a]
\item[throwErrnoIfMinus1\_~:: Num a => String -> IO a -> IO ()]\combineitems
  Instantiate \code{throwErrnoIf} and \code{throwErrnoIf\_} with the predicate
  \code{(< -1)}.

\item[throwErrnoIfMinus1Retry~~:: Num a => String -> IO a -> IO a]
\item[throwErrnoIfMinus1Retry\_~:: Num a => String -> IO a -> IO ()]%
  \combineitems Instantiate \code{throwErrnoIfRetry} and
  \code{throwErrnoIfRetry\_} with the predicate \code{(< -1)}.

\item[throwErrnoIfNull~~~~~~:: String -> IO (Ptr a) -> IO (Ptr a)]
\item[throwErrnoIfNullRetry~:: String -> IO (Ptr a) -> IO (Ptr a)]%
  \combineitems Instantiate \code{throwErrnoIf} and \code{throwErrnoIfRetry}
  with the predicate \code{(== Ptr.nullPtr)}.
\end{codedesc}


\appendix
\newpage
\section{Rationale}

The following includes a justification of design decisions whose virtue may
not be appreciated without further explanation.  The content is sorted by
section numbers.
%
\begin{description}
\item[\ref{sec:foreign-types}] 
\item[\ref{sec:import}] It might appear as if it were feasible to
  require an automatic consistency check between the Haskell type given in an
  import declaration and the argument and result types of the imported
  external entity.  Unfortunately, this is in general not possible with
  reasonable effort.  For example, in the case of the C calling convention the
  only feasible approach would be to generate a C prototype from the Haskell
  type and leave it to the C compiler to match this prototype about the
  prototype for the imported function specified in the C header file.
  However, the Haskell type is lacking some information that would be required
  to pursue this route.  In particular, the Haskell type does not contain any
  information as to when \code{const} modifiers have to be emitted.
\item[\ref{sec:extent}] A foreign declaration specifies all calling-convention
  dependent information in a string.  The idea here is to separate out the
  information that is needed to statically analyse the Haskell program from
  information needed to generate the code interacting with the foreign
  language.  This is, in particular, expected to be helpful for tools
  processing Haskell source code.

  The following information is provided outside of the
  string specifying the external entity.  This information is sufficient for
  the front-end of a Haskell compiler or other Haskell tools (like a
  documentation tool) to infer identifier definition and use information as
  well as type information.
  %
  \begin{itemize}
  \item What Haskell function is being defined or used.
  \item What the Haskell type of that function is.
  \item Whether the function is being \emph{defined} (e.g., foreign import) or
    \emph{used} (e.g., foreign export).
  \item The calling convention.
  \end{itemize}
  %
  All further information (i.e., the information contained in the string
  specifying the external entity) is merely needed by a code generator
  supporting the specified calling convention.
  
  Moreover, as variation of the supported calling convention determines the
  exact syntax supported in the specification of the external entity, we
  ensure that the first-level grammar is implementation independent.
\item[\ref{sec:ccall}] C header files are always included by \gterm{\#include
    "\gnterm{fname}"}.  There is no explicit support for \gterm{\#include
    <\gnterm{fname}>} style inclusion.  The ISO C99~\cite{C99} standard
  guarantees that any search path that would be used for a \gterm{\#include
    <\gnterm{fname}>} is also used for \gterm{\#include "\gnterm{fname}"} and
  it is guaranteed that these paths are searched after all paths that are
  unique to \gterm{\#include "\gnterm{fname}"}.
  
  We require that \gnterm{fname} ends on \code{.h} to make parsing of the
  specification of external entities unambiguous.

  The specification of include files has been kept to a
  minimum on purpose.  Libraries often require a multitude of include
  directives, some of which may be system-dependent.  Any design that attempts
  to cover all possible configurations would introduce significant complexity.
  Moreover, using the simple design, a custom include file can be specified
  that uses the standard C preprocessor features to include all relevant
  headers.
  
  There are no facilities to specify link information, such as, for example,
  the name of a library archive.  Link information can be complex and is often
  system-dependent.  Again, comprehensive support would have made the design
  significantly more complex.  In contrast to include files, simple support that
  offloads the complexity to standard C mechanisms seems not to be possible
  here.  Instead, we delegate the handling of link information to the package
  management system of the Haskell implementation.
\end{description}


\bibliographystyle{plain}
\bibliography{ffi}

\begin{DRAFT}
\section{FIXME}

Malcolm writes,
%
\begin{verbatim}
Standard C Calls
~~~~~~~~~~~~~~~~
The productions

    fdecl  -> 'import' callconv [safety] entity var '::' ftype
    entity -> " ['static'] [fname] ['&'] ['['lib']'] [cid] "

suggest that the entity string must always be present, but could be
"".  I was wondering if there is any real difficulty in permitting
an empty entity string to be omitted altogether?  The idea would be
to be able to write

    foreign import ccall sin :: CFloat -> CFloat

as at present rather than

    foreign import ccall "" sin :: CFloat -> CFloat

It isn't a big deal, and it might be worth enforcing the literal string
quotes just for uniformity, but I thought I'd raise the issue anyway.
\end{verbatim}
%
SimonPJ supports this.

SimonM proposes to put provisions into place that make the FFI definition
compatible with the forthcoming library spec.  (Maybe list the names of the
FFI modules as they would be under the new library naming scheme in the
appendix.)

SimonM writes,
%
\begin{verbatim}
IOError
~~~~~~~

One thing that bugs me about writing FFI code at the moment is that
there isn't a portable way to generate an IOError except through
CError.throwErrno and friends.  There's also no way to change the info
(location, filename, handle) in an existing IOError.  This is the single
cause of non-portability in a lot of the FFI code I've written recently.

Also, we currently can't provide a portable version of CError.hs.

I'd like to see something like this:

---------
data IOErrorType -- abstract
mkIOError :: IOErrorType
            -> String
          -> Maybe FilePath
          -> Maybe Handle
            -> IOError

alreadyExistsError :: IOErrorType
alreadyInUseError  :: IOErrorType
...

addIOErrorLoc        :: String             -> IO a -> IO a
addIOErrorLocAndPath :: String -> FilePath -> IO a -> IO a
---------

This doesn't require any more functionality than is already required by
Haskell 98 (although perhaps the range of IOErrorType could be expanded
somewhat), and it should sit just as well on top of Nhc's implementation
of IOErrors as GHC's.  Furthermore it would let us provide a portable
implementation of CError.hs.

The addIOError functions are very useful.  Quite often an error is
generated by throwErrno in a function which is a long way from the one
which the consumer of a library initially called; for example when I get
an error from Directory.renameFile I want the error message to say
"Directory.renameFile" and contain the filename that I passed to
renameFile.  So you'd implement renameFile as

renameFile file1 file2 = 
  addIOErrorLocAndPath "Directoy.renameFile" file1 $ do
   ...
\end{verbatim}%$

\end{DRAFT}

\end{document}
